# Microsoft Azure AZ-204 Complete Study Guide

This document is a comprehensive, self-contained reference designed to prepare you for the **AZ-204: Developing Solutions for Microsoft Azure** certification exam without relying on extra study materials. It expands on the Microsoft skills outline with implementation detail, practical guidance, quotas, decision matrices, and quick-reference tables.

> üöÄ **Welcome!** Treat this as your flight manual. Skim the maps (tables), run the drills (hands-on checklists), then rehearse scenarios until decisions feel automatic.

### Official Skills Outline (Effective April 11, 2025) & Mapping
The official Microsoft outline groups skills into five domains. This guide aligns each bullet to the internal section for targeted review.

| Official Domain (Weight) | Microsoft Bullet (Abbrev) | Section(s) Here |
| --- | --- | --- |
| Develop Azure Compute Solutions (25-30%) | Container solutions (images, ACR, ACI, ACA) | 1.3 (Containerized Workloads) |
|  | App Service web apps (create, diagnostics, deploy, config, autoscale, slots) | 1.1 App Service |
|  | Azure Functions (create/config, bindings, triggers) | 1.2 Functions (+ host.json appendix) |
| Develop for Azure Storage (15-20%) | Cosmos DB ops, consistency, change feed | 2.8 Cosmos DB |
|  | Blob properties/metadata, data ops, lifecycle policies | 2.2 Blob Storage + lifecycle JSON |
| Implement Azure Security (15-20%) | AuthN/AuthZ w/ Identity Platform & Entra ID | 3.1 Identity & expanded token section |
|  | Shared Access Signatures | 2.1 / Added SAS Examples (below) |
|  | Microsoft Graph interaction | 3.1 (Graph) & Appendix Recipes |
|  | Secure config w/ App Config & Key Vault | 3.4 Key Vault + Security Patterns |
|  | Managed identities | 3.1 Managed Identities + Code Samples |
| Monitor, Troubleshoot, Optimize (5-10%) | App Insights metrics/logs/traces | 4.1‚Äì4.3 + KQL 4.4 |
|  | Alerts, availability tests | 4.1, 4.6, Hands-on Checklist |
| Connect & Consume Azure / Third-Party (20-25%) | API Management (create, document, secure, policies) | 5.5 API Management |
|  | Event-driven (Event Grid, Event Hubs) | 5.4 Event-Driven Architectures |
|  | Messaging (Service Bus, Queue Storage) | 5.3 Service Bus, 2.5 Queue Storage, 5.4 comparisons |

## How to Use This Guide üí°
- Start with the **Exam Essentials** to understand logistics, scheduling, and prerequisites.
- Work through the skill areas in sequence. Within each section:
  - Read the **Service Overview** for context.
  - Study the **Design Decisions**, **Pricing & Limits**, and **Security** points for scenario-based questions.
  - Practice with the provided **CLI/PowerShell/code snippets** to build muscle memory.
  - Review the **üß† Exam Watch** callouts‚Äîthey mimic trick questions and subtle exam cues.
- Use the **Hands-on Checklists** to reinforce knowledge via mini-labs.
- Revisit the **Appendices** for cheat sheets, CLI commands, KQL patterns, pricing tiers, and last-minute cramming.

---

## Exam Essentials
| Item | Detail |
| --- | --- |
| Certification | Microsoft Certified: Azure Developer Associate |
| Exam Code | AZ-204 |
| Exam Duration | 120 minutes (+ 30 minutes survey & NDA) |
| Format | ~40-60 questions: multiple choice, drag-and-drop, hot area, build list, case studies, review screen to revisit questions |
| Passing Score | 700/1000 |
| Registration | Pearson VUE or Certiport via [Microsoft Learn profile](https://learn.microsoft.com/credentials/) |
| Cost | ~USD 165 (regional pricing varies; student discount up to 50%) |
| Prerequisites | Recommended 1-2 years professional development experience with 6+ months Azure hands-on |
| Renewal | Annual, free online renewal assessment (open book) |
| Allowed Tools | On-screen whiteboard & calculator; no external materials |

### Question Types to Expect
- **Case studies:** Long scenario, 4-6 linked questions. Read requirements carefully; some questions during case study cannot be revisited.
- **Single-answer & multiple-answer multiple choice:** Pay attention to prompts such as "select two" or "select all that apply".
- **Drag-and-drop:** Order steps (deployment pipelines, lifecycle policies, etc.).
- **Hot area:** Choose configuration options in mock Azure portal screenshots.
- **Yes/No statements:** Evaluate scenario compliance with requirements.

### Exam Day Tips
- Use the *Mark for review* functionality to revisit uncertain questions, but note case study locking.
- Manage time: target 1.5-2 minutes per question, leaving ~20 minutes for review.
- Read each scenario twice; identify key verbs like *implement*, *configure*, *diagnose*, *secure*.

---

## 1. Develop Azure Compute Solutions (25-30%)

### 1.1 Azure App Service (Web Apps, API Apps, WebJobs)
**Overview:** PaaS hosting for web applications, REST APIs, background jobs. Supports Windows and Linux, multiple languages, container images.

**Key Concepts**
- App Service Plan defines region, pricing tier, scaling. Apps inherit plan resources.
- Deployment slots allow zero-downtime deployments (swap with warmup).
- Built-in authentication with Microsoft Entra ID, social providers, custom OpenID Connect.
- Integration features: VNet integration (outbound), hybrid connections, private endpoints (inbound for apps), custom domains, managed certificates, backups, staging slots, deployment center (GitHub, DevOps, local Git).
- Scaling: Manual scale, autoscale rules (CPU, memory, HTTP queue, custom metrics). Scale-out limit based on tier (Standard up to 10 instances, Premium v3 up to 30, Isolated v2 up to 200).

**Pricing & Limits**
- Free/Shared: Shared compute, no SLA, only HTTP. Ideal for dev/test.
- Basic/Standard: Dedicated VMs, support custom domains/SSL, daily backup (Standard), 99.95% SLA.
- Premium v2/v3: Enhanced hardware, zone redundancy, VNet integration, 99.95% SLA.
- Isolated (App Service Environment v3): Single-tenant, inside VNet, 99.95% SLA.
- Instances scale to 64-bit worker, ephemeral storage 250 GB per instance.

**Deployment Options**
- `az webapp up`, local Git, ZIP deployment (`Run From Package`), container deployment from Docker Hub/ACR, GitHub Actions, Azure DevOps.
- Automate infrastructure with Bicep/ARM (`Microsoft.Web/serverfarms`, `Microsoft.Web/sites`).

**Configuration**
- App settings vs connection strings (environment-specific values). Use slot settings for slot-specific values.
- `WEBSITE_RUN_FROM_PACKAGE=1` for immutable deployments.
- `WEBSITE_NODE_DEFAULT_VERSION`, `FUNCTIONS_EXTENSION_VERSION` for runtime selection.

**Diagnostics**
- Application Logging (Filesystem or Blob), HTTP Logging, Detailed Error Messages, Failed Request Tracing.
- Use `Kudu` (`https://<app>.scm.azurewebsites.net`) for console, debug console, process explorer.

**Security**
- Enforce HTTPS, minimum TLS version, certificates (upload PFX), managed certificates (free) for custom domains.
- Managed identity for access to Key Vault, Storage, SQL Database (via `Azure AD Authentication`).

**CLI Quickstart**
```bash
az appservice plan create \
  --name plan-prod \
  --resource-group rg-az204 \
  --sku P1v3 \
  --is-linux

az webapp create \
  --name contoso-api \
  --plan plan-prod \
  --runtime "DOTNETCORE:8.0"

az webapp config appsettings set \
  --name contoso-api \
  --resource-group rg-az204 \
  --settings APPINSIGHTS_INSTRUMENTATIONKEY=$APPINSIGHTS_KEY
```

**üß† Exam Watch**
- If requirement states "needs to run in VNet without public internet", choose **Isolated** plan or **App Service Environment**.
- For GitHub integration and staging slots, ensure tier is **Standard** or higher.
- If a requirement mentions per-region scaling beyond 30 instances, only **Isolated** (ASE) meets it.

**üõ†Ô∏è Hands-on Checklist**
- Deploy a .NET/Node web app using deployment slots.
- Integrate with Key Vault using system-assigned managed identity.
- Configure autoscale rule (scale out when CPU > 70% for 10 minutes).
- Enable diagnostic logs to Log Analytics workspace.

**üí° Tip:** Pair deployment slots with warm-up pings (`WEBSITE_SWAP_WARMUP_PING_PATH`) to prevent first-request latency after swap.
**‚ö†Ô∏è Pitfall:** Forgetting to mark connection strings as *slot settings* can leak production secrets into staging after a swap.

**Feature & Limit Matrix (Exam-Relevant)**
| Capability | Free/Shared | Basic | Standard | Premium v2/v3 | Isolated (ASE v3) |
| --- | --- | --- | --- | --- | --- |
| Custom Domains/SSL | Partial (no custom SSL) | Yes | Yes | Yes | Yes |
| Deployment Slots | 0 | 0 | 5 | 20 (v3) | 20 |
| Daily Backups | No | Manual | Yes | Yes (higher retention) | Yes |
| Autoscale | No | Manual only | Yes | Yes | Yes |
| VNet Integration (Outbound) | No | Regional (Linux limited) | Yes | Yes (enhanced) | Built-in |
| Private Endpoint (Inbound) | No | No | Yes (preview) | Yes | Yes |
| Zone Redundancy | No | No | Optional (v3) | Yes (v3) | Yes |
| Max Instances | Shared | Per plan size | 10 | 30 | 200 |

**Slot Swap Gotchas**
- Settings marked as slot settings do NOT swap (connection strings marked as slot, app settings flagged, key vault references).
- Always warm up target slot if using `autoSwap` or pre-swap tests (use `WEBSITE_SWAP_WARMUP_PING_PATH`).
- Sticky vs non-sticky settings likely to appear in scenario.

**When to Choose App Service vs Alternatives**
- Choose **App Service** when: Traditional web/API, need built-in auth, moderate scaling (<30 instances), simplified operations.
- Choose **Container Apps** when: Microservices + Dapr, scale to zero, event/KEDA triggers for containers.
- Choose **AKS** when: Full Kubernetes control, custom operators, service mesh, complex networking.

**Fast Decision Table (Exam Style)**
| Requirement | Best Choice | Why |
| --- | --- | --- |
| Zero downtime deploy with instant rollback | Slots (Standard+) | Swap + swap back |
| Need >30 instances in region | Isolated/ASE | Only tier supporting >30 |
| Eliminate cold starts for Functions-like behavior | Premium Functions or Always On App Service | Pre-warmed instances |
| Host Windows & Linux apps separated cost domains | Separate plans | Plans isolate compute |

**‚ö†Ô∏è Common Mistakes**
- ‚ùó Setting custom domain before DNS propagation completes (validation fails).
- üîí Forgetting to enable `HTTPS Only` and TLS 1.2 -> security scenario penalty.
- üÜî Using admin credentials instead of managed identity for database/storage access.

### 1.2 Azure Functions
**Overview:** Event-driven serverless compute for lightweight code execution. Supports .NET, Node.js, Python, Java, PowerShell, Go, custom handlers.

**Hosting Plans**
- Consumption: Serverless, pay per execution/time, scales automatically (dynamic compute). Default timeout is 5 minutes, configurable up to 10 minutes via host.json.
- Premium: Pre-warmed instances, unlimited execution duration, VNet integration, no cold start, custom scaling, available at P1d, P1v2 etc. Billing per vCPU-second + GB-s + executions.
- Dedicated (App Service Plan): Uses existing App Service Plan capacity.
- Azure Container Apps: Host function container with KEDA-based scale.

**Triggers & Bindings**
- Triggers: HTTP, Timer, Queue Storage, Service Bus Queue/Topic, Event Hub, Event Grid, Cosmos DB (change feed), Blob Storage, Durable orchestrations, SignalR, etc.
- Input/Output bindings for simplified data operations (e.g., Storage queue output, Cosmos input).
- Attributes (C#) or decorators (Python/JS). Configuration in `function.json`.

**Durable Functions**
- Patterns: Function chaining, fan-out/fan-in, async HTTP APIs (status polling), human interaction (external events), monitor (scheduled checks).
- Entities: Durable stateful objects accessed via ID.
- State stored in Azure Storage (Queues, Tables, Blob) or Netherite provider (Event Hubs).
- Concurrency management: `DurableOrchestrationClient` handles state. Use `OrchestrationTrigger` attribute.

**Scaling Model**
- Consumption uses dynamic compute; `WEBSITE_MAX_DYNAMIC_APPLICATION_SCALE_OUT` default 200 instances.
- Scale Controller monitors triggers (queue length, HTTP requests). Configure host.json for concurrency (e.g., `extensions.http.maxConcurrentRequests`).

**Local Development**
- Use Azure Functions Core Tools (`npm install -g azure-functions-core-tools@4`).
- Debug with Visual Studio, VS Code extension.
- Local.settings.json holds secrets for dev (never deploy).

**Security**
- Authorization levels: Anonymous, Function (function key), Admin (host key). HTTP triggers can integrate with App Service Authentication/Authorization.
- Use managed identities to access resources.
- Integrate with API Management for rate limiting, transformation.

**Monitoring**
- Application Insights integration (default). Monitor cold starts, failures (`Failures` blade), Live Metrics.
- `AzureWebJobsDashboard` (deprecated). Use `Functions` blade for metrics.

**CLI Deployment**
```bash
func init Processor --worker-runtime dotnet
cd Processor
func new --name ProcessOrder --template "Queue trigger" --authlevel function
func azure functionapp publish contoso-func --dotnet
```

**üß† Exam Watch**
- For long-running operations requiring state, choose **Durable Functions**. Standard timer functions cannot exceed 10 minutes reliably.
- Consumption plan cannot integrate directly with VNet; require Premium or App Service plan + VNet integration.
- To avoid cold start, use Premium plan or pre-warmed instances.

**üõ†Ô∏è Hands-on Checklist**
- Build HTTP-triggered function returning JSON payload.
- Create queue-triggered function writing to Cosmos DB, configure `host.json` for retry policy.
- Implement Durable function (fan-out/fan-in) to process multiple activities.
- Configure managed identity to access Key Vault secret.

**host.json Essentials (Selected Keys)**
```jsonc
{
  "version": "2.0",
  "extensions": {
    "http": {
      "routePrefix": "api",
      "maxOutstandingRequests": 200,
      "maxConcurrentRequests": 100
    },
    "queues": {
      "batchSize": 16,
      "newBatchThreshold": 8,
      "visibilityTimeout": "00:00:30"
    },
    "serviceBus": {
      "prefetchCount": 20,
      "messageHandlerOptions": {
        "autoCompleteMessages": false,
        "maxConcurrentCalls": 16
      }
    }
  },
  "functionTimeout": "00:10:00"
}
```

**Deterministic Durable Orchestrations**
- No DateTime.UtcNow (use `context.CurrentUtcDateTime`).
- No random GUID (use `context.NewGuid()`).
- Avoid non-deterministic I/O inside orchestrator; call activity functions.
- Replay-safe logging: use `if (!context.IsReplaying)` for verbose logs.

**Retry Pattern Example (C# Activity)**
```csharp
var retryOptions = new RetryOptions(firstRetryInterval: TimeSpan.FromSeconds(5), maxNumberOfAttempts: 5)
{
    BackoffCoefficient = 2, Handle = ex => ex is HttpRequestException
};
await context.CallActivityWithRetryAsync("ProcessPayment", retryOptions, orderId);
```

**Scaling Nuances**
- High concurrency HTTP: Prefer setting `WEBSITE_MAX_DYNAMIC_APPLICATION_SCALE_OUT` only if throttling observed; otherwise allow controller heuristics.
- CPU-bound workloads benefit from Premium dedicated cores vs consumption burst concurrency.

**Cold Start Mitigations**
- Use .NET isolated worker trimming, minimal dependencies, Premium pre-warmed, or Always On.
- Group latency-critical functions into one app; keep background triggers separate to avoid scaling noise.

### 1.3 Containerized Workloads üê≥

#### Azure Container Apps (ACA)
- Serverless container platform using Kubernetes + Dapr + KEDA under the hood.
- Supports revisions with traffic splitting (blue/green). Exposes ingress with Ingress controller.
- Scaling: Minimum/maximum replicas, scale based on HTTP requests, events (KEDA), or custom metrics.
- Environments (managed VNet). Pricing: Consumption (per vCPU-second, GB-second, requests), Dedicated workload profiles (Consumption, Dedicated, Premium).
- Integrations: Dapr building blocks (pub/sub, service invocation, bindings, state store), managed identity, secrets from Key Vault.
- Deploy via `az containerapp up`, Bicep, Terraform.

#### Azure Kubernetes Service (AKS) *(Skim unless AKS appears in scenario)*
- Managed Kubernetes with free control plane. You pay for agent nodes + add-ons.
- Features: Node pools (Linux/Windows), auto-upgrade (patch, rapid), cluster autoscaler, KEDA, Azure CNI vs Kubenet, network policies (calico), Azure Policy for AKS, Azure RBAC integration, pod-managed identities (Workload Identity), ingress controllers (NGINX, Application Gateway, Traefik).
- Node scaling: Manual, cluster autoscaler, virtual nodes via Virtual Kubelet (backed by ACI).
- Security: Azure AD integration, RBAC, Pod Security Standards, secrets encryption with Key Vault, private clusters, network policies. Integrate with Azure Defender for Kubernetes.
- Storage: PersistentVolumes backed by Azure Disk/File, CSI drivers.
- Monitoring: Azure Monitor for containers, Container insights, `kubectl top`, `kubectl logs`, `az aks browse`.
- Upgrades: Node image upgrades, control plane upgrades. Use `az aks upgrade`. Always upgrade node pools after control plane.

#### Azure Container Instances (ACI)
- Run containers without orchestrator. Start in seconds. Suitable for batch jobs, data processing, dev/test.
- Features: VNet integration, GPU support (N series), Linux/Windows containers, ephemeral storage, event-driven runs via Logic Apps, container groups (multi-container w shared network/volume).
- Limits: 4 vCPU, 14 GB memory per container group (region-specific). Billing per second.

#### Web App for Containers
- App Service variant to deploy custom Docker containers (single container per app or multi-container via Docker Compose for Linux).
- Maintains App Service features (deployment slots, scaling, diagnostics). Great for simple container hosting.

#### Azure Container Registry (ACR)
- Private Docker registry. Tiers:
  - Basic: 10 GiB storage, 2 vCPU, cost-effective.
  - Standard: 100 GiB, 10 vCPU, recommended for prod.
  - Premium: Up to 500 GiB, 30 vCPU, geo-replication, content trust, private endpoints, scope maps, tokens, quarantine, availability zones.
- Features: ACR Tasks (build images, scheduled builds, base-image updates), `acr import`, retention policies, `az acr run` for server-side builds.
- Integration with AKS/ACA using managed identity or admin credentials (avoid admin for security).

**üß† Exam Watch**
- For multi-container orchestration with advanced networking and scaling, choose **AKS**.
- For quick job run requiring GPU, choose **ACI** with `--gpu` flag.
- For blue/green traffic splitting on container revisions with minimal management, choose **Container Apps**.

**üõ†Ô∏è Hands-on Checklist**
- Deploy containerized API to ACA using `az containerapp up` and configure autoscale rule.
- Create AKS cluster with system + user node pools, enable monitoring, deploy sample app with ingress.
- Push container image to ACR and configure AKS pull secrets.

**Container Apps Scaling Rule Examples (YAML Snippets)**
```yaml
scale:
  minReplicas: 0
  maxReplicas: 10
  rules:
  - name: http-concurrency
    http:
      concurrentRequests: 50
  - name: queue-jobs
    azureQueue:
      queueName: tasks
      queueLength: 100
      auth:
        - secretRef: storage-conn
          triggerParameter: connection
```

**Revisions Strategy**
- Single revision mode for simplicity; multiple revisions for canary (e.g., 10% new, 90% old) prior to full cutover.
- Disable old revision after full traffic shift to control cost.

**AKS Best Practice Highlights**
- Use workload identity (AAD) instead of deprecated pod-managed identity.
- Separate system node pool (OS/system pods) from user pools; use taints if necessary.
- Enable Azure Policy + Defender for vulnerability scanning.
- Use CSI Secrets Store with Key Vault provider for secret mounting.

**Security in Containers**
- Run as non-root (configure in Dockerfile & deployment spec).
- Use image scanning (ACR Tasks, Microsoft Defender). Avoid `latest` tags.

**Common Pitfalls**
- Over-provision requests/limits causing scheduling failure.
- Missing liveness/readiness probes leads to slow failure detection.

### 1.4 Virtual Machines & Scale Sets (for completeness)
- Azure Virtual Machines: IaaS compute. Exam may ask about using VM for custom workloads.
- VM Scale Sets: Manage identical VMs. Autoscale based on CPU, memory, schedule, custom metrics. Integrate with Load Balancer or Application Gateway.
- Images: Marketplace, custom images, Shared Image Gallery.
- Extensions: Custom Script, Desired State Configuration, Azure Monitor agent.
- Use Cases: When full control over OS required, running background tasks not well suited to PaaS.

### 1.5 Background & Batch Processing
- **WebJobs:** Run scripts/binaries in App Service context. Continuous (long-running) or triggered (schedule/queue). Bindings similar to Functions but less overhead. Ideal for same app domain tasks.
- **Azure Batch:** *(Rarely deep on exam)* High-scale batch processing. Define pools (VM configuration), jobs, tasks. Supports container workloads. Auto-scale formula by queue length. Integration with Storage for input/output. 
- **Azure Logic Apps:** Workflow orchestration. Consumption (serverless, pay per action), Standard (single-tenant, built on Functions runtime, better VNet). Use connectors for SaaS integration. Built-in connectors vs managed connectors.
- **Data Factory / Synapse Pipelines:** *(Exam focus is usually on messaging/event patterns instead)* ETL/ELT, data movement. Build pipelines with triggers (schedule, tumbling window, event). Integration runtime (Azure, self-hosted, SSIS). Manage via JSON definitions.

### 1.6 Deployment Automation & DevOps
- **Infrastructure as Code:**
  - ARM templates: JSON schema, parameters, variables, functions (`concat`, `reference`, `copyIndex`), outputs, linked templates, secureString.
  - Bicep: Preferred DSL, compiles to ARM. Features: modules, loops, conditions, existing resources. Use `az bicep build`, `az deployment group create`.
  - Terraform: HCL, provider `azurerm`. Manage state in Azure Storage + Key Vault (SAS). Use backend configuration, workspace for environments, modules for reuse.
- **Deployment Commands:**
  ```bash
  az deployment group create \
    --resource-group rg-az204 \
    --template-file appservice.bicep \
    --parameters environment=prod

  terraform init
  terraform plan -out tfplan
  terraform apply tfplan
  ```
- **CI/CD:**
  - GitHub Actions: Use `azure/login`, `azure/webapps-deploy`, `azure/functions-action`, `azure/cli` actions. Manage secrets via GitHub Secrets.
  - Azure DevOps Pipelines: YAML vs Classic. Service connections for Azure Resource Manager. Use variable groups, secure files.
- **Release Strategies:** Blue/Green deployment (App Service slots), Continuous deployment, Rolling updates (AKS), Canary deployments (Container Apps revisions, APIM versioning), Feature flags (App Configuration).
- **Testing Stages:** Build, Unit test, Integration test, Deploy to staging, Functional tests, Swap to production.

**üõ†Ô∏è Hands-on Checklist**
- Write Bicep template to deploy App Service + plan + Application Insights.
- Build GitHub Action that builds and deploys Functions app.
- Implement release pipeline with manual approval and slot swap.

---

## 2. Develop for Azure Storage (15-20%)
> üì¶ Keep momentum: mastering storage patterns (SAS, lifecycle, partitioning) unlocks many scenario points.

### 2.1 Storage Account Fundamentals
**Types**
- General-purpose v2 (GPv2) - recommended default; supports blobs, files, queues, tables, Data Lake Storage.
- Premium block blob (`BlockBlobStorage`) - SSD-backed for low latency.
- Premium file (`FileStorage`) - SMB 3.0 shares on SSD.
- Premium page blob (`PageBlobStorage`) - for unmanaged disks.

**Endpoints**
- Format: `https://<account>.blob.core.windows.net`, `.file`, `.queue`, `.table`, `.dfs` (Data Lake), `.web` (static website).
- Custom domains supported for blob endpoint.

**Access Tiers**
- Hot, Cool, Cold (preview), Archive. Minimum retention periods: Cool 30 days, Archive 180 days. Archive requires rehydration (Standard vs High priority).
- Data Lake Storage shares same tiers for hierarchical namespace accounts.

**Redundancy**
- LRS, ZRS, GRS, RA-GRS, GZRS, RA-GZRS. Understand RPO/RTO trade-offs.
- Cross-region replication triggers asynchronous copy; `Get-AzStorageAccount` reveals secondary location.

**Networking**
- Public access (enabled/disabled). Use Firewall rules, virtual network service endpoints, private endpoints, shared access signatures.
- SAS token types: Account SAS, Service SAS, User Delegation SAS (requires Azure AD identity & SignedIdentifier).

**Security**
- Encryption at rest with Microsoft-managed keys by default. Customer-managed keys via Key Vault or HSM.
- Azure AD RBAC for data plane (Blob Data Contributor, Queue Data Contributor, etc.). Use `az role assignment create`.

**Data Protection**
- Soft delete for blobs and containers (retention up to 365 days).
- Container version-level immutability policies (legal hold, time-based retention).
- Change feed (Blob) for audit & ingestion pipelines.
- Point-in-time restore for block blobs and containers.

**Monitoring**
- Metrics (transaction counts, latency). Diagnostic logs to Log Analytics or Storage.

### 2.2 Blob Storage Deep Dive üì¶
- Blob types: Block (max 190.7 TiB), append (log data, sequential writes), page (8 TiB, 512-byte pages for random access).
- Transfer: AzCopy, `Start-AzStorageBlobCopy`, `UploadAsync` (SDK). Use `BlobClient`, `BlobServiceClient`, `BlobContainerClient` (Azure SDK for .NET/Python/Node).
- Features: Static website hosting (`$web` container), blob snapshots, incremental copies, object replication (synchronous between accounts), lifecycle management rules (JSON or portal) to tier or delete.
- Performance optimization: Use chunked uploads (`StageBlockAsync`, `CommitBlockListAsync`). For .NET, set `TransferOptions.MaximumConcurrency`.
- Access: Shared access signatures, stored access policies, user delegation SAS, Azure AD RBAC, Access tiers (SetTier), CORS settings.
- Security best practices: Disable anonymous blob access, require TLS 1.2, use private endpoints, enable logging and alerts for high activity.

**.NET Example**
```csharp
BlobClient client = new BlobClient(connectionString, "images", "logo.png");
await client.UploadAsync(stream, overwrite: true);
BlobProperties props = await client.GetPropertiesAsync();
await client.SetMetadataAsync(new Dictionary<string, string> { ["owner"] = "marketing" });
```

**üß† Exam Watch**
- Archive tier blobs cannot be read/modified until rehydrated.
- Data Lake Storage hierarchical namespace adds file system semantics; requires `dfs` endpoint for ACL operations.

**Shared Access Signatures (SAS) Essentials**
- Types: Account SAS (broad services), Service SAS (single resource like blob), User Delegation SAS (Azure AD + finer scope; recommended over account key when possible).
- Permissions shorthand (Blob service): `r`=read, `w`=write, `d`=delete, `l`=list, `c`=create, `a`=add, `x`=delete previous version, `t`=tag, `f`=filter by tag.
- Use stored access policy to enable revocation without regenerating keys.

**User Delegation SAS (CLI Example)**
```bash
az storage blob generate-sas \
  --account-name $STORAGE \
  --container-name images \
  --name logo.png \
  --permissions r \
  --expiry $(date -v+15M -u +%Y-%m-%dT%H:%MZ) \
  --auth-mode login \
  --as-user
```
Returns token only; append to URL: `https://$STORAGE.blob.core.windows.net/images/logo.png?<SAS>`

**.NET User Delegation SAS (Snippet)**
```csharp
var blobClient = new BlobClient(new Uri(blobUrl), credential);
var userDelegationKey = await new BlobServiceClient(new Uri(serviceUrl), credential)
  .GetUserDelegationKeyAsync(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddMinutes(15));
BlobSasBuilder sas = new BlobSasBuilder(BlobSasPermissions.Read, DateTimeOffset.UtcNow.AddMinutes(15))
{ BlobContainerName = container, BlobName = blobName }; 
string token = sas.ToSasQueryParameters(userDelegationKey, accountName).ToString();
```

**When to Prefer User Delegation SAS**
- Centralized key rotation (no shared keys to rotate in code) and tighter scope using Azure AD identity.
- Least privilege scenarios distributing time-bound access externally.

**üí° Tip:** For large batch blob uploads, parallelize with `TransferOptions.MaximumConcurrency` but cap threads to avoid throttling (429) and high RU/transaction cost.
**‚ö†Ô∏è Pitfall:** Generating SAS tokens with overly long expirations increases risk; keep lifetimes minimal and revoke via stored access policy if needed.

### 2.3 Azure Data Lake Storage Gen2
- Combines Blob storage with hierarchical namespace.
- Supports POSIX-style ACLs (access control entries). Set at directory/file level.
- Use `abfss://` URI scheme in analytics workloads.
- Integrates with Synapse, Databricks, HDInsight, Azure Data Explorer.
- Security: Azure AD integration, managed identity for analytics services, ACL inheritance.
- Performance: Append/flush semantics for big data; consider partitioning (directory structure) for efficient reads.

### 2.4 Azure Table Storage & Cosmos DB Table API
- NoSQL key-value store, schema-less. Entities limited to 1 MB, up to 252 properties.
- PartitionKey + RowKey combination uniquely identifies entity; supports batching (100 operations in same partition).
- Query via OData filter (`PartitionKey eq 'A' and RowKey gt '0'`). SDKs available.
- Table API in Cosmos DB adds global distribution, secondary indexes, automatic indexing.
- Pricing: Storage transactions + capacity. Table API in Cosmos DB priced per RU/s + storage.

### 2.5 Azure Queue Storage
- Simple queue service with base64-encoded messages up to 64 KB (can use [larger message storage pattern](https://learn.microsoft.com/azure/storage/queues/storage-queue-how-to-large-messages)).
- Visibility timeout, dequeue count, poison queue (`<queue>-poison`).
- Provide at-least-once delivery; implement idempotent processors.
- SAS tokens or Shared Key for auth; integrate with Functions queue trigger.
- CLI: `az storage queue create`, `az storage message put`.

### 2.6 Azure Files & Azure File Sync
- SMB shares accessible via Windows, Linux, macOS. Offers Azure AD DS integration, AD Kerberos (preview), on-prem AD.
- NFS 4.1 for Linux (requires premium tier).
- Snapshots for point-in-time restore. Soft delete available.
- Azure File Sync caches Azure Files on Windows Server, cloud tiering to free space. Requires Storage Sync Service, registered server, sync group.

### 2.7 Azure Disk Storage (Managed Disks)
- Disk types: Standard HDD, Standard SSD, Premium SSD, Premium SSD v2, Ultra Disk (low latency, high IOPS), ZRS options in some tiers.
- Snapshots, incremental snapshots, shared disks (multiple VMs, cluster scenarios).
- Disk encryption using SSE + CMK or ADE + Disk Encryption Set.

### 2.8 Azure Cosmos DB
**APIs & Models**
- Core (SQL) API: JSON documents with SQL-like query.
- MongoDB API: Wire protocol compatibility.
- Cassandra API, Gremlin API (graph), Table API, PostgreSQL (Hyperscale Citus) API.

**Throughput**
- Provisioned throughput (RU/s) per container or database. Autoscale (10x range) charges on max RU used per hour. Serverless charges per request (request unit consumption).
- Request unit (RU) cost depends on item size, indexed properties, query complexity. Use `QueryMetrics` to analyze.
- Burst capacity: Temporary RU boost to handle sudden spikes (preview).

**Consistency Levels**
- Strong, Bounded Staleness, Session (default), Consistent Prefix, Eventual. Understand latency, availability trade-offs.
- Multi-region writes require Session or lower for 99.999% SLA.

**Partitioning**
- Partition key critical for distribution. Choose property with high cardinality and even access.
- Logical partition size limit 20 GB. Cross-partition queries require RU overhead.

**Indexing**
- Automatic indexing enabled. Customize with indexing policy: include/exclude paths, composite indexes (for ORDER BY on multiple properties), spatial indexes.
- TTL per container or item for automatic deletion.

**Change Feed**
- Append-only log of item changes. Use Azure Functions trigger, SDK change feed processor.
- Lease container manages checkpoints. Supports full fidelity mode (before/after images).

**Security**
- Master keys (primary/secondary), resource tokens (limited scope/time), Azure AD RBAC, IP firewalls, private endpoints, customer-managed keys.

**Backup**
- Periodic backup (every 4 hours, 2 copies) or Continuous backup (point-in-time restore, 7/30-day retention).

**CLI**
```bash
az cosmosdb create \
  --name cos-az204 \
  --resource-group rg-az204 \
  --locations regionName=eastus failoverPriority=0 isZoneRedundant=false \
  --capabilities EnableServerless

az cosmosdb sql database create --account-name cos-az204 --name appdb --resource-group rg-az204
az cosmosdb sql container create \
  --account-name cos-az204 --database-name appdb --name items \
  --partition-key-path "/tenantId" --throughput 400
```

**üß† Exam Watch**
- Multi-region writes require **multi-master** configuration with conflict resolution policies (Last Writer Wins or custom stored procedure).
- For TTL-based data expiration, configure TTL at container level. Use item-level TTL = -1 to inherit default.

### 2.9 Relational Databases

#### Azure SQL Database
- Deployment options: Single database, Elastic pool, Managed instance (near feature parity with SQL Server).
- Service tiers:
  - DTU model (Basic/Standard/Premium).
  - vCore model: General Purpose (5x9), Business Critical (4x9), Hyperscale (100 TB). Serverless compute tier (auto-pause, per-second billing).
- High availability: Always-on, zone redundant (Business Critical), auto-failover groups.
- Features: Automatic tuning, Query Store, Columnstore indexes, In-Memory OLTP, dynamic data masking, row-level security, temporal tables.
- Security: Transparent Data Encryption, Always Encrypted, Azure AD authentication, firewall rules, private endpoints, auditing, threat detection.
- Tools: SQLCMD, Azure Data Studio, EF Core migrations, ARM/Bicep `Microsoft.Sql/servers/databases`.

#### Azure Database for PostgreSQL/MySQL/MariaDB
- Single server (retiring) vs Flexible Server (preferred): configurable maintenance window, zone redundant high availability.
- Hyperscale (PostgreSQL) for sharding via Citus.
- Backup retention up to 35 days. Automatic failover in HA config.
- Security: TLS enforced, private endpoints, AAD auth (PostgreSQL preview), firewall rules.

#### Azure SQL Managed Instance
- Useful when migrating SQL Server with Agent, cross-database transactions, CLR integration.
- VNet-only service; requires subnet with NSG, route table.
- Pricing: General Purpose vs Business Critical, license included or Azure Hybrid Benefit.

### 2.10 Caching & Search
- **Azure Cache for Redis**: In-memory cache. TTL per key. Use `StackExchange.Redis`. Premium features: clustering, persistence (RDB/AOF), geo-replication, Redis modules (JSON, Search). Enterprise for active-active replication.
- **Azure Cognitive Search**: Indexing service with built-in analyzers, cognitive skills (AI enrichment). Pricing per search unit (replica x partition). Integrates with Cosmos DB, SQL, blob as data source.
- **Azure SignalR Service**: Real-time messaging. Use serverless plan (Functions integration). Pricing tiers with connections per unit.

**üõ†Ô∏è Hands-on Checklist**
- Configure Storage lifecycle management policy to move blobs to Cool tier and delete after 365 days.
- Build Cosmos DB container with autoscale and implement change feed consumer.
- Create Azure SQL database with private endpoint and managed identity auth for App Service.
- Implement Redis cache in .NET app with fallback to Cosmos DB.

**Blob Lifecycle Policy Sample (JSON)**
```json
{
  "rules": [
    {
      "name": "tier-and-expire",
      "enabled": true,
      "type": "Lifecycle",
      "definition": {
        "filters": { "blobTypes": ["blockBlob"], "prefixMatch": ["logs/"] },
        "actions": {
          "baseBlob": {
            "tierToCool": { "daysAfterModificationGreaterThan": 30 },
            "tierToArchive": { "daysAfterModificationGreaterThan": 180 },
            "delete": { "daysAfterModificationGreaterThan": 730 }
          }
        }
      }
    }
  ]
}
```

**Cosmos DB Partition Key Examples**
| Scenario | Good Key | Why |
| --- | --- | --- |
| Multi-tenant SaaS | /tenantId | Even distribution, natural query filter |
| User-centric social feed | /userId | Locality for user queries |
| IoT telemetry | /deviceId | Time-series partitioning per device |
| E-commerce orders | /customerId (plus orderId as id) | Frequent customer-based queries |
| Gaming sessions | /gameSessionId | Isolates session state |

**What is an RU (Request Unit)?**
An RU is the normalized currency of throughput in Cosmos DB. Every operation (read, write, query, upsert) consumes RUs based on CPU, IO, and index work. You provision (or autoscale) RU/s. If usage exceeds current RU/s, requests are throttled with 429 (Request Rate Too Large) including `x-ms-retry-after-ms` for backoff.

Typical approximate costs (1 KB item, default indexing):
- Point read (Get by id + partition key): ~1 RU
- Insert/Upsert 1 KB item: ~5 RU (higher if many indexed paths)
- In-partition filtered query returning few docs: 2‚Äì5 RU
- Cross-partition aggregate query (fan-out): 10s‚Äì100s RU
- Metadata ops (scale throughput): 0 RU (control plane)

Cost drivers:
- Item size: larger JSON = more RU per op.
- Indexing: each indexed path adds RU cost to writes.
- Fan-out: queries without partition key scatter to all partitions adding RU totals.
- Projection: returning only needed fields reduces RU + payload.

**Bad Partition Key Choices (and why)**
- Low cardinality (e.g., /region with 3 values) ‚Üí Few logical partitions ‚Üí hotspots, limited parallelism.
- Skewed distribution (1 tenant dominates 70% traffic) ‚Üí Throttling on that logical partition while others idle.
- Mutable property (e.g., /status that changes) ‚Üí Partition key cannot be updated; forces data migration.
- Monotonic increasing values (e.g., /timestamp truncated to minute) ‚Üí Sequential inserts target same physical partition ‚Üí write queueing.
- Excessive randomness losing locality (/uuid when queries filter by user) ‚Üí Every query fans out; high RU waste.

Mitigation / remediation strategies:
- Redesign container with better key; migrate via Change Feed processor.
- Use synthetic composite key (`${tenantId}|${yyyyMM}`) balancing tenant + time.
- Denormalize / materialize views for hot query patterns inside a partition.

**Cosmos RU Optimization (Practical)**
- Project only required fields (`SELECT c.id, c.status`) not `SELECT *`.
- ALWAYS include partition key in point reads and most queries to avoid fan-out.
- Customize indexing policy: exclude unused paths to cut write RU.
- Pre-compute aggregates for dashboards; avoid scanning millions each request.
- TTL to purge cold data -> smaller working set & cheaper queries.
- Autoscale for spiky workloads; saves cost vs over-provisioning fixed RU/s.
- Cache hot reads (Redis) reducing RU for repeat fetches.
- Change Feed + materialized projections for query-optimized containers.

Key metrics to monitor:
- Normalized RU Consumption (% of provisioned) ‚Üí sustained >80% near capacity.
- Throttled Requests (429) count ‚Üí revisit partitioning or scale.
- Index Transformation Progress ‚Üí temporary RU spikes during policy changes.

Exam Watch: Given an access pattern (e.g., queries filtered by tenant + date), best key balances even distribution + query predicate to eliminate fan-out.

**Service Bus Messaging Patterns**
| Pattern | Mechanism | Notes |
| --- | --- | --- |
| Competing Consumers | Multiple processors on one queue | Horizontal scale; ensure idempotency |
| Pub/Sub | Topics + multiple subscriptions | Add filters for routing |
| Delayed Delivery | Scheduled messages | Use `ScheduleMessageAsync` |
| Dead Letter Handling | DLQ inspection | Replay after fix or move to analysis store |
| FIFO | Sessions | One active session lock at a time |

**Idempotency Strategy**
- Include `messageId`/dedupe key in message metadata; store processed IDs in fast store (Redis) with TTL.
- For Functions, leverage `ServiceBusReceivedMessage.MessageId` and implement application-level dedupe.

---

## 3. Implement Azure Security (15-20%)
> üîê Security mastery pays double: it appears directly AND inside other scenario domains.

### 3.1 Identity, Authentication, and Authorization

#### Microsoft Entra ID (Azure Active Directory)
- **App Registrations:** Configure platform (Web, SPA, Native, Single-page, Mobile/desktop). Define redirect URIs, logout URLs, publisher domain.
- **Permissions:** API permissions (delegated vs application). Admin consent required for privileged scopes. Use `Expose an API` to define scopes & app roles.
- **Certificates & Secrets:** Store credentials; secrets expire (1-24 months). Certificates recommended for automation.
- **Token Customization:** Optional claims (groups, roles). Use `prefers reduced token size` with group IDs or overage claim.
 - **Tenancy Models:** Single-tenant (only home directory users), Multi-tenant (any Entra ID tenant with consent), Multi-tenant + personal (include Microsoft Accounts via `common` or `organizations` authority). Exam may ask which authority endpoint: `organizations`, `common`, `consumers`, or specific tenant GUID.
 - **Service Principals:** Instance of application in a tenant. App registration lives in home tenant; service principal objects created in each consuming tenant after consent.
 - **Enterprise Applications:** Blade showing service principal objects (assign users/groups to app roles here).
 - **App Roles vs Groups:** App roles appear as `roles` claim; groups appear as `groups` claim (GUIDs). Use app roles for coarse-grained authorization logic when possible.

**Token Anatomy (OIDC/OAuth)**
- **ID Token:** User identity (subject, name, preferred_username, aud, iss, exp). Used by client to establish session. Not for API authorization logic beyond basic validation.
- **Access Token:** Contains scopes or roles for resource API; in Entra ID often JWT (sometimes opaque for some resources). Audience = resource app ID URI / application ID.
- **Refresh Token:** Long-lived (rotating) token to obtain new access tokens. Not sent to API. Sensitive; store securely (backend server or secure store on device). 
- **Common Claims:** `sub` (stable per app), `oid` (object id user), `tid` (tenant id), `scp` (delegated scopes), `roles` (application roles), `aud` (resource), `exp` (expiry), `nbf` (not before), `iat` (issued at), `ver` (token version), `appid` (client id for application permissions), `upn` (user principal name), `groups` (GUID list).
  - Exam nuance: `scp` appears only in delegated user flows; `roles` appears in application permission or role assignment cases.

**Token Validation Checklist (API)**
1. Verify signature with Entra ID signing keys (JWKS endpoint).
2. Check `aud` matches API's Application ID URI or client ID.
3. Check `iss` matches expected tenant issuer (e.g. `https://login.microsoftonline.com/<tenantId>/v2.0`).
4. Ensure `exp` not expired and `nbf` valid.
5. Authorize based on `scp` (delegated) or `roles` (application roles) ‚Äî not both interchangeably.
6. Optionally enforce `tid` (restrict to specific tenant) for single-tenant requirements.

**Consent & Admin Consent**
- User consent: Allowed if permission is user-consentable (`User.Read`).
- Admin consent: Required for high-privilege scopes (e.g., `Directory.Read.All`). Admin grants for entire tenant; service principal updated.
- Multi-tenant app first access triggers consent screen; failing to configure publisher domain / branding may reduce trust.

**Confidential vs Public Clients**
- Confidential: Server-side (can keep a secret/certificate) ‚Äî web apps, daemons, web APIs. Use Authorization Code + client secret/cert or Client Credentials.
- Public: SPA, native/mobile, devices ‚Äî no client secret; must use PKCE, device code, or implicit (deprecated ‚Äî exam expects Auth Code + PKCE instead of implicit for SPAs).

**Managed Identity vs Service Principal**
| Aspect | Managed Identity | Service Principal (App Reg + Secret/Cert) |
| --- | --- | --- |
| Credential Management | Automatic (rotated) | Manual rotation (policy) |
| Creation | Enable on resource | Create app registration + secret/cert | 
| Scope of Use | Within Azure (supported services) | Anywhere (scripts, external) |
| Security Posture | Least exposure (no secret visible) | Risk of secret leakage |
| Ideal Use | Resource-to-resource auth (Key Vault, Storage) | External automation, multi-cloud tooling |

**OIDC Authority URLs (v2 endpoint)**
- `https://login.microsoftonline.com/<tenantId>/v2.0` (tenant-specific)
- `.../organizations/v2.0` (AAD work/school accounts only)
- `.../common/v2.0` (multi-tenant + personal accounts)
- `.../consumers/v2.0` (personal Microsoft accounts only)

**MSAL Library Pattern (Pseudo C#)**
```csharp
IConfidentialClientApplication app = ConfidentialClientApplicationBuilder
  .Create(clientId)
  .WithClientSecret(clientSecret)
  .WithAuthority(AzureCloudInstance.AzurePublic, tenantId)
  .Build();
string[] scopes = new[]{"api://api-app-id/.default"}; // Use .default for application permissions
AuthenticationResult result = await app.AcquireTokenForClient(scopes).ExecuteAsync();
string accessToken = result.AccessToken;
```

**Multi-tenant App Registration Steps (High-Level)**
1. Register app (leave `Supported account types` = Accounts in any org directory).
2. Expose API (set Application ID URI, define scopes / roles).
3. Publish branding & publisher domain (DNS verification) to reduce consent friction.
4. Implement per-tenant provisioning if needed (store `tid`, `servicePrincipalId`).

**Group Claims Considerations**
- For large group membership, token uses overage claim with Graph query required (`hasgroups` claim) ‚Äî app must fetch groups from Graph.
- Use app roles to avoid large tokens and reduce Graph dependency.

**Authorization Strategies**
- Role-based (use `roles` claim) for coarse access.
- Scope-based (use `scp`) for fine-grained delegated operations.
- Hybrid: roles for static coarse boundaries + custom resource-level checks inside service.

**RBAC vs ABAC (Attribute-Based)**
- Entra ID primarily RBAC; for ABAC-like patterns, embed attributes/claims (departments, roles) or use external policy engine.
- Azure RBAC (control plane) vs Application Authorization (data plane). Exam may ask which role type to grant Storage data access ‚Äî answer: Storage Blob Data Contributor (data action) not generic Contributor.

**Common Exam Pitfalls**
- Selecting Client Credentials flow for SPA (incorrect; must use Auth Code + PKCE).
- Using access token for user identity UI decisions instead of ID token (should use ID token claims or Graph call).
- Storing refresh tokens in local storage of SPA (security risk) ‚Äî prefer memory & silent refresh with iframe or token renewal.

#### OAuth 2.0 / OpenID Connect Flows
- **Authorization Code Flow:** Web apps (confidential clients). Exchange code for tokens using client secret or certificate.
- **PKCE (Proof Key for Code Exchange):** SPAs/mobile; mitigates interception.
- **Client Credentials Flow:** Service-to-service calls. Managed identity often better for Azure resources.
- **On-Behalf-Of Flow:** API calling downstream API on behalf of user. Requires `offline_access` and `profile` scopes.
- **Device Code Flow:** CLI apps without browser.

#### Managed Identities for Azure Resources
- System-assigned: Lifecycle tied to resource.
- User-assigned: Standalone resource, attach to multiple services.
- Supported services: App Service, Functions, Container Apps, AKS (workload identity), VM/VMSS, Logic Apps Standard, Data Factory, Synapse.
- Use `DefaultAzureCredential` from Azure Identity SDK (sequentially tries managed identity, CLI, environment).

**Role-Based Access Control (RBAC)**
- Scope: Management group > subscription > resource group > resource.
- Built-in roles: Owner, Contributor, Reader, Storage Blob Data Contributor, Cosmos DB Built-in Data Reader, Key Vault Secrets User.
- Custom roles: JSON definition with `Actions`, `NotActions`, `DataActions`, `AssignableScopes`.
- Use `az role assignment create --assignee <principal> --role "Storage Blob Data Contributor" --scope <resourceId>`.

**Conditional Access** (awareness)
- Enforce MFA, block legacy auth, require compliant device. Not configured by developers but may appear in exam scenario.

### 3.2 App Service & Functions Authentication
- Enable **App Service Authentication/Authorization** (Easy Auth). Identity providers: Microsoft, Google, Facebook, Twitter, OpenID Connect, Azure AD B2C.
- Options: Allow anonymous requests, require authentication, or allow/redirect.
- Token storage: App Service provides tokens via `X-MS-CLIENT-PRINCIPAL` header; Functions uses `ClaimsPrincipal` (Isolated worker) or `HttpRequestData`.

### 3.3 Azure AD B2C
- Customer identity. Pricing per Monthly Active User (MAU). Free tier 50k MAU.
- **User flows:** Pre-built sign-up/sign-in, password reset, profile edit.
- **Custom policies:** Identity Experience Framework (IEF) XML definitions for complex flows.
- Integrate with App Service/SPA. Use MSAL libraries with B2C authority.
- Multi-factor authentication built-in. Federation with social providers (Google, Facebook, etc.).

### 3.4 Application Secrets & Key Vault üîê
- **Azure Key Vault:**
  - Objects: Secrets, Keys, Certificates. Each has operations (Get, List, Set, Wrap/Unwrap, Sign/Verify).
  - Access options: Vault access policy, Azure RBAC. RBAC roles (Key Vault Secrets Officer, Secrets User).
  - Networking: Firewalls, private endpoints (enabled by default to block public). Bypass for trusted services.
  - Soft delete & purge protection (enabled by default). Recover deleted secrets.
  - Logging: Diagnostic logging to Log Analytics.
- **Managed HSM:** Dedicated hardware security module cluster. Use for payment, HSM compliance. Access via local RBAC. Supports full audit logging.
- **Integration:** App configuration referencing Key Vault, App Service Key Vault references (`@Microsoft.KeyVault(SecretUri=...)`).
- **Rotation:** Key rotation, secret rotation bypass using event grid/azure automation.
  - **Key Rotation Mechanisms:** Automatic rotation policy (keys) vs custom rotation (secrets) triggered by Event Grid `Microsoft.KeyVault.SecretNearExpiry` events.
  - **Versioning:** Every set operation creates a new version; reference a specific version or let apps always fetch latest (trade-off: immediate vs controlled rollout).
  - **Secrets vs Keys vs Certificates:** Use secrets for simple string values (connection strings), keys for cryptographic operations (signing, encryption), certificates for TLS/SSL (contains private key + metadata). Do not store large binaries ‚Äî size limit ~25KB for secrets.
  - **Throttling Considerations:** Excessive GetSecret calls -> latency. Cache in memory or use Azure App Configuration referencing Key Vault.
  - **Soft Delete Flow:** Delete -> (recoverable) -> purge (irreversible). Purge protection prevents immediate purge.
  - **Backup/Restore:** Secrets/keys exported securely; cannot edit exported JSON, restore into another vault (same subscription/tenant restrictions apply).
  - **Logging Sensitive Data:** Ensure Key Vault diagnostic logs shipped to Log Analytics with retention policy aligned to compliance.
  - **Access Review:** Periodically review role assignments or access policies for principle of least privilege (exam scenario: revoke broad access).
  - **Pricing Essentials:** Standard tier billed per operation (secret get/list/set, key ops), Premium adds HSM‚Äëbacked keys and higher cost per operation. Managed HSM priced per hour + operations (dedicated cluster). Frequent cryptographic operations might justify caching or using locally stored symmetric keys if compliance allows.

**Key Vault Tier Comparison (Exam-Relevant)**
| Feature | Standard Vault | Premium Vault | Managed HSM |
| --- | --- | --- | --- |
| Secret Storage | Yes | Yes | No (keys only) |
| Software Keys | Yes | Yes | No |
| HSM Keys | No | Yes (multi-tenant HSM) | Yes (single-tenant FIPS 140-2 Level 3) |
| Availability | Regional | Regional | Region (dedicated) |
| Private Endpoints | Yes | Yes | Yes |
| RBAC / Access Policy | Yes | Yes | Local RBAC (different model) |
| Cost Model | Per operation | Higher per op (HSM ops) | Provisioned capacity + ops |
| Use Case | General secrets & basic keys | Mixed secret + occasional HSM | High-security crypto isolation |

### 3.5 Data Protection & Encryption
- Data at rest encryption: Storage Service Encryption for Storage, Transparent Data Encryption for SQL, confidential computing (Always Encrypted, enclaves).
- Data in transit: TLS 1.2, enforce HTTPS. Use `RequireSecureTransport` (Storage), `Enforce HTTPS` (App Service).
- Column-level security (SQL), Dynamic Data Masking (SQL), Row-level security.
- Client-side encryption for storage using Azure SDK + Key Vault keys.

### 3.6 Network Security
- **Private Endpoints:** Provide private IP for PaaS services (Storage, SQL, Key Vault, Web Apps). Access via VNet only.
- **Service Endpoints:** Extend VNet to Azure services at public endpoint but secure via VNet ACL.
- **Application Gateway / WAF:** Layer 7 load balancer with SSL offload, WAF (OWASP rules). Integrate with AKS via AGIC.
- **Azure Front Door:** Global load balancing, SSL termination, WAF, caching.
- **Network Security Groups (NSG):** Ingress/egress rules on subnets or NICs.
- **Azure Firewall:** Centralized network control, DNAT, SNAT, application rules.
- **API Management:** Use policies for JWT validation, IP filtering, rate limiting, mutual TLS.

### 3.7 Secure Coding & Compliance
- Use `Microsoft.Identity.Web` (ASP.NET Core) for easier token acquisition; `Azure.Identity` for credential retrieval.
- Parameterize SQL queries or use ORM to avoid injection.
- Validate inputs for Azure Functions (ModelState, FluentValidation). Use `ILogger` and sanitized logs.
- Use `RetryPolicy` with exponential backoff for transient errors (e.g., `Polly` in .NET).
- Compliance frameworks: SOC, ISO, HIPAA. Use Azure Policy to enforce requirements.
- Logging: Mask secrets, use secure storage for logs, set retention policies.

**üß† Exam Watch**
- If requirement mentions "no secrets in code" and uses App Service, expect Key Vault + managed identity reference.
- For service requiring certificate-based mutual TLS, use API Management or Application Gateway with client certificate authentication.

**üõ†Ô∏è Hands-on Checklist**
- Register Azure AD app and implement OAuth authorization code flow in web app.
- Enable App Service Authentication with Azure AD and limit to organizational users.
- Store SQL connection string in Key Vault, integrate with function via managed identity.
- Configure private endpoint for Storage account and test access from VNet and public internet.

**Managed Identity Code (C# Example)**
```csharp
// DefaultAzureCredential tries Managed Identity first in Azure
var credential = new DefaultAzureCredential();
var secretClient = new SecretClient(new Uri("https://kv-demo.vault.azure.net/"), credential);
KeyVaultSecret secret = await secretClient.GetSecretAsync("SqlPassword");
```

**Key Vault Access Model Decision**
| Requirement | Vault Access Policy | Azure RBAC |
| --- | --- | --- |
| Fine-grained operations per object type | Yes | Limited (role-based) |
| Centralized at scale (many vaults) | Harder | Easier (role inheritance) |
| Legacy scripts relying on access policies | Yes | Might need migration |

**Secret Reference in App Settings**
`@Microsoft.KeyVault(SecretUri=https://kv-demo.vault.azure.net/secrets/SqlPassword/xxxxxxxx)`

**API Permissions vs App Roles**
- Scopes (delegated): User context required.
- App Roles (application permissions): Daemon/service context.

**Microsoft Graph Call (Delegated) ‚Äì C# Example**
```csharp
var scopes = new[]{"User.Read"};
var pca = PublicClientApplicationBuilder.Create(clientId)
  .WithRedirectUri("http://localhost")
  .Build();
AuthenticationResult auth = await pca.AcquireTokenInteractive(scopes).ExecuteAsync();
var graphClient = new GraphServiceClient(new DelegateAuthenticationProvider(req => {
  req.Headers.Authorization = new AuthenticationHeaderValue("Bearer", auth.AccessToken);
  return Task.CompletedTask;
}));
var me = await graphClient.Me.Request().GetAsync();
Console.WriteLine(me.DisplayName);
```

**Graph Throttling**
- On HTTP 429 or 503, respect `Retry-After` header; implement exponential backoff.
- Batch requests (up to 20) with `/v1.0/$batch` for efficiency (be mindful of combined limits).

**üîê Tip:** Prefer `User Delegation SAS` + managed identity over account keys to minimize key rotation overhead.
**‚ö†Ô∏è Pitfall:** Using `groups` claim for authorization when user belongs to many groups can cause token overage‚Äîswitch to app roles or Graph lookup.

---

## 4. Monitor, Troubleshoot, and Optimize Azure Solutions (5-10%)
> üß™ Think like a detective‚Äîinstrument first so you can answer ‚Äúwhy‚Äù under pressure.

### 4.1 Azure Monitor Ecosystem üß™
- **Metrics:** Numeric time-series data (CPU, memory, requests). Gathered every minute. Use metric alerts for near real-time detection.
- **Logs:** Log Analytics workspace (Kusto). Collect from Azure resources, VM agents, custom logs.
- **Application Insights:** Application performance monitoring. Automatically instruments .NET/Java apps. Features: request tracking, dependency tracking, exception logging, availability tests (ping, multistep), Live Metrics Stream, Profiler, Snapshot debugger.
  - **Instrumentation Steps (.NET Minimal API Example):**
    1. Add package: `dotnet add package Microsoft.ApplicationInsights.AspNetCore`
    2. In `Program.cs`: `builder.Services.AddApplicationInsightsTelemetry();`
    3. Configure sampling: `builder.Services.Configure<TelemetryConfiguration>(c => c.DefaultTelemetrySink.TelemetryProcessorChainBuilder.UseSampling(5));`
    4. Track custom event: `telemetryClient.TrackEvent("OrderSubmitted", new(){{"OrderId", id}});`
  - **Availability Tests:**
    - Standard ping test: interval (default 5 min), custom success criteria (HTTP 200, response content match).
    - Multi-step (browser) test: scripted sequence for login or transaction path (Playwright-based newer model).
    - Consider placing tests in multiple regions for SLA validation; configure alert rule when failures exceed threshold.
  - **Live Metrics:** Real-time (second-level) streaming not persisted‚Äîused for warm diagnostics during incidents.
  - **Profiler & Snapshot Debugger:** Enable in App Service/Functions for low overhead capture of CPU hotspots / exception state (requires site extension for some runtimes).
  
**üß™ Tip:** Create *one* alert rule per logical symptom (e.g., high failure rate) with multiple action groups, instead of many narrowly-scoped duplicate alerts that cause noise.
**‚ö†Ô∏è Pitfall:** Excessively low sampling (0% or full) can either hide issues or drive up telemetry cost‚Äîtune adaptive sampling after baseline traffic observed.
- **Alerting:** Metric alerts (static/dynamic thresholds), log alerts (KQL), activity log alerts, smart detection, action groups (email, SMS, webhook, ITSM).
- **Dashboards:** Workbooks, metrics explorer, Azure dashboard.

### 4.2 Instrumentation & Telemetry
- SDK instrumentation (Application Insights SDK `TelemetryClient`). Custom events/metrics using `TrackEvent`, `TrackMetric`.
- Distributed tracing using `OperationId`/`ParentId` to correlate requests across services.
- Logging frameworks integration: Serilog, ILogger, log4net, NLog bridging to App Insights or Log Analytics.
- Use `appsettings.json` for sampling configuration.
- `Azure Monitor OpenTelemetry` preview for standardization.

### 4.3 Diagnostic Logging
- **App Service:** HTTP logs, application logs (filesystem/Blob), detailed error logs. Enable `web server logging` for short-term storage.
- **Functions:** Host logging, function-level logging, `AzureWebJobsDashboard` (legacy). Application Insights for telemetry.
- **AKS:** Container insights (collects stdout/stderr, node metrics). Use `az aks enable-addons monitoring`.
- **Storage:** Storage analytics logging for requests; Azure Monitor metrics for capacity, transactions.
- **Cosmos DB:** Azure Monitor metrics (RU consumption, latency). Diagnostic logs for data-plane operations.

### 4.4 Kusto Query Language (KQL) Cheat Sheet
- Basic query: `AppRequests | where success == false | summarize count() by operation_Name`.
- Join: `AppRequests | join kind=inner AppDependencies on operation_Id`.
- Time filtering: `| where timestamp > ago(1h)`.
- Aggregation: `| summarize avg(duration) by bin(timestamp, 5m)`.
- Rendering: `| render timechart`.
- Parse JSON: `| extend payload = parse_json(requestBody)`.

### 4.5 Troubleshooting Playbook
- **App Service:** Use Diagnose and Solve Problems blade, process explorer, remote debugging (Visual Studio), snapshots, memory dumps, App Insights Profiler.
- **Functions:** Check Function App metrics (execution count, error count). Use `func azure functionapp logstream` to tail logs. Adjust scaling (max concurrent calls) via host.json.
- **AKS:** `kubectl describe pod`, `kubectl logs`, `kubectl get events`, `kubectl exec`. Use `az aks nodepool upgrade` for patching. Check `ContainerInsights` health.
- **Storage:** Use `Storage` metrics for throttling (ServerBusy), `GetBlobServiceProperties` for logging.
- **Cosmos DB:** Investigate 429 (request rate too large). Implement retries with exponential backoff (`RetryOptions`), check partition hot spots.

### 4.6 Performance & Optimization
- Use caching (Redis) to reduce database load.
- Async I/O, connection pooling (SQL connection re-use via `using` statements). Use managed identity for connection stringless auth.
- Optimize Functions by precompiling .NET assemblies, minimizing cold-start dependencies, and using Premium plan pre-warmed instances when predictable latency is required.
- Cosmos DB query optimization: Use partition key in queries, pre-aggregate data, define proper indexes.
- Storage performance: For high throughput, use multiple blob upload threads, consider premium tiers.

### 4.7 Cost Management
- **Cost Analysis:** Analyze usage by resource group, tags. Use budgets with alerts.
- **Advisor Recommendations:** Right-size or shutdown underutilized resources, buy reserved capacity (App Service, SQL, Cosmos DB, Cache) for steady workloads.
- **Serverless:** Monitor execution count, duration. Consider Premium plan for high volume vs consumption to reduce cost and cold start.
- **Storage:** Lifecycle management to move to cooler tiers, delete old snapshots.
- **Cosmos DB:** Autoscale vs manual. Lower RU/s during off-hours with scheduled scripts.

### 4.8 Reliability & Testing
- Design for failure: Multi-region deployments, geo-redundant storage, Zone redundant App Service.
- Chaos engineering: Azure Chaos Studio (fault injection). Test failover in SQL Failover groups, Cosmos multi-region.
- Implement unit, integration, load testing. Use Azure Load Testing service.
- Use `azd` pipeline templates for test & deploy.

**üõ†Ô∏è Hands-on Checklist**
- Configure Application Insights availability test for web app.
- Create log alert for Functions failure rate > 5% over 15 minutes.
- Run KQL query to find slowest API operations (>1 second).
- Set budget alert per resource group and review Advisor cost recommendations.

**KQL Advanced Patterns**
```kql
// Identify top failing dependencies by count & duration
dependencies
| where success == false or duration > 2s
| summarize failCount = count(), avgDuration=avg(duration) by target, type
| top 10 by failCount desc

// Function cold start detection (Functions isolated: look for long first invocation)
requests
| where operation_Name startswith "Function" and duration > 2s
| summarize avg(duration), p95=percentile(duration,95) by cloud_RoleInstance

// RU consumption spikes (Cosmos DB custom logs via diagnostic setting)
AzureDiagnostics
| where Category == "DataPlaneRequests" and resource_type_s == "Microsoft.DocumentDB/databaseAccounts"
| summarize totalRU=sum(todouble(requestCharge_s)) by bin(TimeGenerated, 5m)
```

**Cost Guardrails**
- Enable budget alerts at 70/90/100% thresholds.
- Use `--tier` selection scripts to standardize sizing before production.
- Adopt tagging policy to enforce `CostCenter` & `Environment`.

---

## 5. Connect to & Consume Azure Services and Third-Party Services (20-25%)
> üîó Integration questions reward clarity on when to choose messaging vs events‚Äîpractice decision tables.

### 5.1 RESTful Communication & SDK Usage
- HttpClient best practices: reuse `HttpClient` (use `IHttpClientFactory`), configure retries/backoff/polly, handle `HttpRequestException`.
- Serialization: `System.Text.Json` (set `PropertyNamingPolicy`, `DefaultIgnoreCondition`). For .NET Minimal APIs, use `results.Ok()`. For Node.js, use Axios, fetch.
- Azure SDK design guidelines: client object per resource type (`BlobServiceClient`, `SecretClient`), async operations by default, `Response<T>` wrappers.
- Authentication: `DefaultAzureCredential`, `ClientSecretCredential`, `ClientCertificateCredential`. Use environment variables `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_CLIENT_SECRET` for local dev.
- Resiliency: Implement retries (exponential, jitter), circuit breakers. Use `RetryPolicy` in `Azure.Core` (`RetryOptions` per client).

### 5.2 Azure Storage Integrations
- Queue + Functions: Configure connection string in app settings, use `QueueTrigger` attribute. Manage poison queue.
- Blob Trigger: Understand polling intervals, scaling limits (512 concurrent invocations per function app). Use event grid for low-latency triggers instead of blob polling if needed.
- Shared Access Signatures: Temporary access for third parties. Use stored access policy to revoke.

### 5.3 Azure Service Bus
- Entities: Queue, Topic/Subscription. Dead-letter sub-queue for poison messages. Sessions for FIFO. Scheduled messages, deferral, auto-forwarding.
- Tiers: Basic (queue only), Standard (topics, sessions), Premium (dedicated resources). Premium provides predictable latency, zone redundancy, VNet support.
- Client library: `Azure.Messaging.ServiceBus`. Use `ServiceBusClient`, `ServiceBusSender`, `ServiceBusProcessor` (auto-complete). Configure `MaxConcurrentCalls`, `PrefetchCount`. Renew message lock with `RenewMessageLock` or `CompleteMessageAsync`.
- Transactions: Group operations (send + complete) in a transaction scope.
- `ServiceBusSessionProcessor` for session-enabled queues.

### 5.4 Event-Driven Architectures
- **Event Grid:** Publish-subscribe eventing. Event sources: Azure services, custom topics/domains, partner topics. Event schema: EventGrid event, CloudEvents v1.0. Delivery: push with exponential backoff (24-hour retry window, 25 attempts). Dead-letter (Storage). Filters (subject, type, advanced filtering). Use `Event Grid subscriptions` for functions/webhooks.
- **Event Hub:** High-throughput event ingestion. Throughput units (1 TU = 1 MB/s or 1000 messages/s ingress). Capture to Storage/ADLS for archival. Checkpoints using Blob storage. Integrate with `EventHubProducerClient`, `EventHubConsumerClient`. Supports Kafka compatibility.
- **IoT Hub:** Device communication. Tiers: Free, Basic, Standard, IoT Hub DPS for provisioning. Features: Device twins, direct methods, cloud-to-device commands.
- **Comparison**: Event Grid (reactive events), Event Hubs (telemetry streaming), Service Bus (enterprise messaging).

### 5.5 API Management (APIM)
- Components: API gateway, developer portal, management plane, analytics.
- Deployment models: Consumption tier (serverless, pay per execution), Developer (non-prod), Basic, Standard, Premium (multi-region, VNet), Isolated (dedicated, compliance).
- Policies: XML-based. Types: Inbound, Outbound, Backend, On-error. Common policies: `validate-jwt`, `set-header`, `set-backend-service`, `rewrite-uri`, `limit-call-rate`, `set-variable`, `cache-lookup-value`.
- Versioning & revisions: Versions accessible by path/hostname/query. Revisions for incremental updates with release notes.
- Security: Subscription keys, JWT validation, client certificate, mutual TLS, IP filtering.
- DevOps: Git integration (repository of configuration), `apim.devOps` resource kit, ARM/Bicep, Terraform modules.
- Integration: Connect to Functions, Web Apps, Logic Apps, container-based APIs. Use `API import` from OpenAPI/Function App/Logic App.

### 5.6 Logic Apps & Power Automate
- Logic Apps connectors (built-in vs managed). Connector throttling & limits (number of API calls per hour). Use concurrency control on loops. Handle retries via `Retry Policy` (Fixed/Exponential).
- Standard vs Consumption: Standard runs in App Service environment, single-tenant, pricing similar to Functions Premium; allows custom connectors, built-in connectors offline.
- Integration with Functions (custom code), Service Bus, Event Grid, connectors for SaaS (Salesforce, Dynamics).

### 5.7 GraphQL & Microsoft Graph
- Microsoft Graph: REST API to access M365 resources. Use delegated (user) or application (app) permissions. Handle throttling (HTTP 429) by using `Retry-After`. Query via `$select`, `$filter`, `$expand`. Use SDKs (.NET, JS).
- GraphQL on Azure: Use Apollo Server on App Service/Functions or Hasura with Postgres. Not exam core but know concept.

### 5.8 External Services & Hybrid Connectivity
- Private endpoints for on-prem data via ExpressRoute/VPN.
- Hybrid Connections for App Service connecting to on-prem host and port.
- Azure Relay for secure connectivity.
- Custom connectors in Logic Apps/Power Apps for third-party APIs.
- Use API Management to mediate and secure third-party APIs.

**Hands-on Checklist**
- Build API Management instance, import Function app OpenAPI definition, apply JWT validation policy.
- Implement Service Bus topic with subscription filters and a Function subscriber.
- Create Event Grid subscription to trigger Automation Runbook on resource group events.
- Connect Logic App to external HTTP API with managed identity authentication.

**Event Grid Advanced Filtering Example (CLI)**
```bash
az eventgrid event-subscription create \
  --name rg-deploy-filter \
  --source-resource-id "/subscriptions/$SUB/resourceGroups/rg-az204" \
  --endpoint-type webhook --endpoint https://func-app/api/hook \
  --advanced-filter data.operationName StringIn "Microsoft.Resources.deployments/write"
```

**APIM Policy Snippet (JWT Validation + Rate Limit)**
```xml
<policies>
 <inbound>
  <base />
  <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized">
    <openid-config url="https://login.microsoftonline.com/{tenantid}/v2.0/.well-known/openid-configuration" />
    <required-claims>
      <claim name="aud">
        <value>api://your-api-client-id</value>
      </claim>
    </required-claims>
  </validate-jwt>
  <rate-limit calls="60" renewal-period="60" />
 </inbound>
 <backend><base /></backend>
 <outbound><base /></outbound>
 <on-error><base /></on-error>
</policies>
```

**Service Bus Subscription Filter Examples**
| Scenario | Filter SQL |
| --- | --- |
| High priority only | `priority = 'high'` |
| Region EU or APAC | `region IN ('eu','apac')` |
| Orders over 1000 | `amount > 1000` |
| Exclude test tenants | `tenantId <> 'test'` |

---

## 6. Deploy and Configure Infrastructure (Cross-cutting)

### 6.1 Governance & Resource Organization
- Resource groups: logical grouping, lifecycle management. Resources can only belong to one resource group.
- Tags: key-value metadata (`Environment=Prod`, `CostCenter=IT`). Use policies to enforce tagging (`Modify` policy to append missing tags).
- Azure Policy: Enforce rules (allowed locations, naming standards, SKUs). Initiative (policy set), assignment scope.
- Management groups: Hierarchical management across subscriptions.
- Blueprints (legacy) replaced by template specs/AVM.

### 6.2 Infrastructure as Code Patterns
- Parameterization per environment.
- Deployment modes: Incremental vs Complete (complete deletes resources not in template).
- Bicep modules to reuse components. Example structure: `main.bicep` referencing `modules/appservice.bicep`.
- Use deployment scripts (PowerShell/Bash) inside ARM to run imperative commands.
- Terraform remote state storage in Azure Blob (`terraform { backend "azurerm" { } }`). Use `terraform import` for existing resources.
- Validation: `az deployment group validate`, `terraform plan`, `what-if` deployments.

### 6.3 Azure Developer CLI (`azd`)
- Workflow: `azd init`, `azd up`, `azd pipeline config`, `azd monitor`.
- Templates for common architectures (web-app + database, functions, container apps). Manage environments (.env, `.azure` folder), support multiple stacks (.NET, TS, Python).
- Integrates with Bicep or Terraform for infrastructure, deploys code, configures monitoring.

### 6.4 Source Control & DevOps Practices
- Branching strategies: GitFlow, trunk-based.
- Environments: dev/test/prod. Use infrastructure pipelines to separate environment deployments.
- Secrets management: Avoid storing secrets in pipeline variables; integrate with Key Vault using `azure/keyvault-secrets` action or Azure DevOps variable groups linked to Key Vault.
- Pull request validation: Build, lint, unit tests, security scans (CodeQL, SAST).
- Artifact storage: Azure Artifacts feeds (NuGet, npm), GitHub Packages, container registries.

### 6.5 Testing & Quality Gates
- Unit testing frameworks: xUnit/nUnit, Jest/Mocha, PyTest. Integrate into pipelines.
- Integration testing: Azurite for Storage, Cosmos DB Emulator, Azure Service Bus emulator (Service Bus Explorer, so on). Use Bicep/Terraform to provision ephemeral environment for tests.
- Load testing: Azure Load Testing (JMeter integration), k6 on containers.
- Security scanning: dependency scanning (Dependabot, WhiteSource), container scanning (ACR `az acr run --cmd "trivy image"`).
- Code coverage metrics to enforce quality gates.

**Hands-on Checklist**
- Create Bicep module for Storage + Function + App Insights, deploy via `azd`.
- Configure GitHub Actions pipeline with environment protection rules and Key Vault secrets.
- Use `terraform plan`/`apply` to deploy Service Bus + API Management resources.

**Bicep Module Structure Example**
```
infra/
  main.bicep
  modules/
    appservice.bicep
    function.bicep
    cosmos.bicep
    monitoring.bicep
```

`main.bicep` (excerpt)
```bicep
module app 'modules/appservice.bicep' = {
  name: 'app'
  params: { name: appName location: location sku: 'P1v3' }
}

module func 'modules/function.bicep' = {
  name: 'func'
  params: { name: '${appName}-func' location: location storageAccountName: stg.name }
}
```

**GitHub Actions Minimal (App Service .NET)**
```yaml
name: build-and-deploy
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: '8.0.x' }
      - run: dotnet publish -c Release -o publish
      - uses: azure/login@v2
        with: { creds: ${{ secrets.AZURE_CREDENTIALS }} }
      - uses: azure/webapps-deploy@v3
        with: { app-name: contoso-api package: publish }
```

**Resiliency Patterns**
| Pattern | Azure Implementation |
| --- | --- |
| Retry with backoff | Polly / SDK built-in retries |
| Circuit Breaker | Polly / custom wrapper |
| Bulkhead | Isolate compute via separate Function Apps / App Service Plans |
| Queue-based load leveling | Service Bus Queue / Storage Queue |
| Compensating transaction | Durable Functions orchestrations |

---

## 7. Scenario Guides & Decision Trees

### 7.1 Serverless API with Storage & Identity
- Requirements: Public REST API, handles bursts, minimal management, secure secrets, logging.
- Solution:
  1. Azure Functions (Consumption or Premium) with HTTP trigger, `WEBSITE_RUN_FROM_PACKAGE=1`.
  2. API Management in front for caching, throttling, developer portal.
  3. Azure Key Vault for secrets, system-assigned managed identity.
  4. Cosmos DB or Azure SQL for persistent storage depending on relational needs.
  5. Application Insights for monitoring.
  6. CI/CD using GitHub Actions with Bicep template deployment.
- Exam Focus: Identify when to use APIM vs Function proxies, how to secure with managed identity, handling keys.

### 7.2 Event-Driven Order Pipeline
- Requirements: Process orders, handle spikes, ensure reliability, track status, integrate with ERP.
- Solution:
  1. Web App places message on Service Bus queue (session-enabled for order ID).
  2. Functions ServiceBusTrigger processes messages, uses Durable Functions to orchestrate downstream API calls.
  3. Cosmos DB stores order state; change feed triggers real-time updates.
  4. Event Grid notifies external systems on status changes.
  5. Monitor via Application Insights + Log Analytics query for failed activities.
- Exam Focus: Understand message locking, concurrent processing, durable orchestrations, change feed usage.

### 7.3 Containerized Microservices with AKS
- Requirements: Microservices, advanced networking, zero downtime updates, secret management.
- Solution:
  1. AKS with Azure CNI, multiple node pools (system + user), autoscaler.
  2. ACR Premium for container images, integrate via managed identity.
  3. Application Gateway Ingress Controller for inbound traffic with WAF.
  4. Azure Key Vault with CSI driver for secrets, Azure Monitor for containers.
  5. CI/CD via GitHub Actions building Docker, push to ACR, `kubectl apply` via `azure/k8s-deploy`.
- Exam Focus: Node pool upgrades, secrets integration, difference between Container Apps and AKS, network configuration.

### 7.4 Hybrid Integration with Logic Apps
- Requirements: Integrate on-premise SQL, send emails, schedule tasks, handle approvals.
- Solution:
  1. Logic App Standard in dedicated plan with VNet integration.
  2. Use on-prem data gateway or Integration Service Environment. Alternatively, use Azure Functions for custom logic.
  3. Connectors: SQL, Outlook, Teams, Service Bus.
  4. Use managed identity for Azure resources, secure with private endpoints.
  5. Monitor using run history, enable diagnostics to Log Analytics.
- Exam Focus: Differences between Consumption and Standard, connectors, authentication.

### 7.5 Lift-and-Shift Web App
- Requirements: Minimal code change migration, uses Windows-specific dependencies, needs custom domain and staging.
- Solution: App Service Windows plan (Standard tier), deployment slots, Azure SQL Managed Instance, Key Vault, App Insights. Use Azure Migrate.
- Exam Focus: Choosing the correct App Service tier, integration with SQL MI, DNS/certificate handling.

---

## 8. Hands-on Practice Plan

| Week | Focus | Activities |
| --- | --- | --- |
| 1 | Compute & Deployment | Build App Service + Function apps, configure deployment slots, implement Bicep deployment |
| 2 | Storage & Data | Create Storage lifecycle rules, queue processors, Cosmos DB change feed app, SQL DB with MI |
| 3 | Security & Identity | Implement OAuth in web app, use managed identities, configure Key Vault integration, secure Storage with private endpoint |
| 4 | Monitoring & Integration | Set up App Insights alerts, create KQL dashboards, deploy APIM, implement Service Bus / Event Grid workflows |
| 5 | Review & Practice | Perform end-to-end deployment with CI/CD, solve sample scenarios, take practice exams |

Complete the mini-labs for each domain. Document results and issues; revisit weak areas.

---

## 9. Sample Exam-style Questions
1. **Compute:** You must run backend workloads in containers, require HTTP scaling, and minimal management. Need revision control and Dapr integration. *Answer:* Azure Container Apps.
2. **Storage:** You must archive documents for 10 years with legal hold and allow deletion after hold release. *Answer:* Blob immutability policies with legal hold/time-based retention.
3. **Security:** An API needs to call Microsoft Graph on behalf of user after being invoked by SPA. *Answer:* Implement OAuth On-Behalf-Of flow with Azure AD, use `AcquireTokenOnBehalfOf`.
4. **Integration:** You receive resource group events to trigger workflows; require filtering event subject. *Answer:* Azure Event Grid with advanced filters.
5. **Monitoring:** Need to correlate request latency with dependency calls across microservices. *Answer:* Application Insights distributed tracing (Operation Id, Telemetry correlation).
6. **DevOps:** Need to enforce naming conventions on deployed resources. *Answer:* Azure Policy (naming convention policy).

Review these scenarios and map back to relevant sections in the guide.

---

## 10. Quick Reference Tables

### 10.1 Compute Service Comparison ‚öôÔ∏è
| Requirement | App Service | Functions | Container Apps | AKS | ACI |
| --- | --- | --- | --- | --- | --- |
| Managed PaaS web hosting | Yes | Limited (HTTP endpoints) | Partial (microservice ingress) | No | No |
| Event-driven serverless | No | Yes | Yes (KEDA triggers) | Requires add-ons (KEDA) | Requires external orchestration |
| Microservices with Dapr | No | No | Yes (built-in) | Yes (install Dapr) | No |
| Full control over OS | No | No | Container-level only | Yes | Container-level only |
| Scale to zero | No | Yes (Consumption/Premium) | Yes | No | Yes |
| Complex networking | Premium/Isolated only | Premium/Dedicated only | Yes | Yes | Yes (VNet integration) |

### 10.2 Storage Options at a Glance üì¶
| Data Type | Service | Key Features |
| --- | --- | --- |
| Binary objects | Blob Storage | Hot/Cool/Archive tiers, lifecycle management, static website |
| Big data analytics | ADLS Gen2 | Hierarchical namespace, ACLs, analytics integration |
| Queue messaging | Queue Storage | Simple messaging, cheap, at-least-once |
| Enterprise messaging | Service Bus | FIFO, sessions, transactions |
| SMB/NFS shares | Azure Files | Snapshots, AD auth, File Sync |
| NoSQL documents | Cosmos DB | Global distribution, low latency |
| Relational | Azure SQL | Managed DB, HA, serverless |

### 10.3 Identity Flows üîê
| Scenario | Flow | Notes |
| --- | --- | --- |
| Web app server-side | Authorization Code | Confidential client with client secret/certificate |
| SPA calling API | Auth Code with PKCE | Use MSAL.js, tokens stored in memory |
| Daemon app | Client Credentials | Use certificate-based auth |
| API calling downstream API | On-Behalf-Of | Exchange token with `AcquireTokenOnBehalfOf` |
| CLI/Device app | Device Code | Out-of-band browser login |

### 10.4 Azure Functions Hosting Limits ‚ö°
| Plan | Max Execution | Scaling | VNet Integration | Cold Start |
| --- | --- | --- | --- | --- |
| Consumption | 10 min (default 5) | Auto, up to 200 instances | No | Possible |
| Premium | Unlimited | Elastic with pre-warmed | Yes | Minimal |
| Dedicated | Unlimited | Manual/Autoscale (App Service plan) | Yes | None |

### 10.5 Service Bus Queue Settings ‚úâÔ∏è
| Property | Default | Notes |
| --- | --- | --- |
| Max message TTL | 14 days | Set `QueueDescription.DefaultMessageTimeToLive` |
| Lock duration | 30 seconds | Extend up to 5 minutes |
| Max delivery count | 10 | After exceeded, message moves to dead-letter |
| Max queue size | 1-80 GB (standard), unlimited (premium) | Quotas vary by tier |

### 10.6 Cosmos DB Throughput Cheat Sheet üåå
| Item Size (KB) | Point Read RU | Write RU | Notes |
| --- | --- | --- | --- |
| 1 KB | 1 RU | 5 RU | Approximate values; indexes affect cost |
| 4 KB | 1 RU | 10 RU | Larger writes cost more RUs |
| Query (partition key) | 3-5 RU | N/A | Use partition filter to minimize cost |
| Cross-partition query | 15+ RU | N/A | Avoid cross partition by modeling data |

### 10.7 Monitoring Alerts Map üß™
| Requirement | Recommended Alert |
| --- | --- |
| Function errors > 1% | Log alert on `requests | where success == false` |
| Cosmos DB throttling | Metric alert on `Total Request Units` vs `Max RU` or `Throttled Requests` |
| App Service CPU > 80% | Metric alert on `CPU Percentage` |
| Storage capacity near limit | Metric alert on `Used Capacity` |
| Service Bus dead-letter | Metric alert on `Incoming Messages` for dead-letter queue |

---

## 11. CLI & PowerShell Cheat Sheet

### Azure CLI Basics
```bash
az login
az account set --subscription "Azure Dev"
az group create --name rg-az204 --location eastus
az deployment group create --resource-group rg-az204 --template-file main.bicep
```

### Key Commands by Service
- App Service: `az webapp create`, `az webapp deployment slot swap`, `az webapp config appsettings set`.
- Functions: `func azure functionapp publish`, `az functionapp create`, `az functionapp config appsettings set`.
- Storage: `az storage account create`, `az storage blob upload`, `az storage queue message put`.
- Cosmos DB: `az cosmosdb sql container throughput update`, `az cosmosdb restorable-database list`.
- Service Bus: `az servicebus namespace create`, `az servicebus queue create`, `az servicebus queue authorization-rule keys list`.
- API Management: `az apim create`, `az apim api import`, `az apim api release create`.
- Monitoring: `az monitor metrics list`, `az monitor alert create`, `az monitor log-analytics workspace create`.

### PowerShell Highlights
```powershell
Connect-AzAccount
New-AzResourceGroup -Name rg-az204 -Location eastus
New-AzStorageAccount -ResourceGroupName rg-az204 -Name staz204demo -SkuName Standard_LRS
Set-AzWebApp -ResourceGroupName rg-az204 -Name contoso-api -AppSettings @{ "KeyVaultReferenceIdentity" = "SystemAssigned" }
```

Use `Az` modules (`Az.Websites`, `Az.Functions`, `Az.ServiceBus`, `Az.Resources`).

> üß† Exam Focus: `az deployment group create` targets a resource group. For subscription scope use `az deployment sub create`.

---

## 12. Appendices üìö

> Quick glance? Remember: üß† exam-critical ‚Ä¢ üí° optimization/design ‚Ä¢ ‚ö†Ô∏è avoid mistakes ‚Ä¢ üìä cost ‚Ä¢ üîê security.

### 12.1 Key Quotas & Limits (Selected)
| Service | Limit (Typical Default) | Notes |
| --- | --- | --- |
| Functions (Consumption) | 200 instances | Per function app; concurrency per instance varies by trigger |
| Service Bus Message Size | 256 KB (Standard) / 1 MB (Premium) | Use claim-check pattern for larger payloads |
| Service Bus Max TTL | 14 days | Queue/Topic setting |
| Storage Account Ingress | Up to 50 Gbps (region) | Depends on redundancy & region |
| Cosmos Logical Partition | 20 GB | Re-partition if close to limit |
| App Service Slots | 0/0/5/20/20 (per tier) | Free/Shared/Basic/Standard/Premium/Isolated |
| Container Apps Max Revisions | 100 | Clean up old revisions |
| Event Grid Delivery Attempts | 24h (~25 tries) | Exponential backoff |
| AKS Node Pools | ~100 (region) | Soft limit; exam cares about separation not exact number |

### 12.2 Decision Matrix (Expanded)
| Scenario | Primary Concern | Choose | Why |
| --- | --- | --- | --- |
| Low latency key-value cache | Sub-ms access | Redis | In-memory store |
| Stream 1M events/min | Throughput | Event Hubs | Partitioned ingestion |
| React to blob uploads | Near real-time | Event Grid | Push-based events |
| Business workflow with approvals | Orchestration | Logic Apps | Connector ecosystem |
| Complex saga with custom code | Deterministic state | Durable Functions | Code-first patterns |
| Global multi-region low-latency DB | <10 ms reads | Cosmos DB | Multi-region replication |

### 12.3 Common Bicep Snippets
**Key Vault Reference**
```bicep
resource kv 'Microsoft.KeyVault/vaults@2023-02-01' existing = { name: kvName }
output kvUri string = kv.properties.vaultUri
```

**Service Bus Queue**
```bicep
resource sb 'Microsoft.ServiceBus/namespaces@2022-10-01-preview' = {
  name: sbName
  location: location
  sku: { name: 'Standard' tier: 'Standard' }
}
resource queue 'Microsoft.ServiceBus/namespaces/queues@2022-10-01-preview' = {
  name: '${sb.name}/orders'
  properties: { maxDeliveryCount: 10 lockDuration: 'PT45S' }
}
```

### 12.4 Sample Azure Policy (Tag Enforcement)
```json
{
  "properties": {
    "displayName": "Append CostCenter Tag",
    "mode": "All",
    "parameters": { "costCenter": { "type": "String" } },
    "policyRule": {
      "if": { "field": "tags['CostCenter']", "exists": "false" },
      "then": { "effect": "modify", "details": { "operations": [ { "operation": "add", "field": "tags['CostCenter']", "value": "[parameters('costCenter')]" } ] } }
    }
  }
}
```

### 12.5 KQL Patterns (Extended)
```kql
// Slow Requests Correlated with Dependency Failures
requests
| where duration > 1s
| join kind=leftouter (dependencies | where success == false) on operation_Id
| summarize failures=countif(success1 == false), avgDuration=avg(duration) by operation_Name
| order by failures desc
```

### 12.6 Resiliency & Error Handling Recipes
| Failure Type | Mitigation | Azure Feature |
| --- | --- | --- |
| Transient network | Retry + jitter | SDK default / Polly |
| Message poison | Move to DLQ after N attempts | Service Bus DLQ |
| Hot partition (Cosmos) | Re-model data | Change partition key strategy |
| Throttling (429) | Exponential backoff | Cosmos SDK built-in |
| Secret rotation | Fetch on demand, cache TTL | Key Vault + App Config |

### 12.7 Quick Code Recipes
**Blob Upload (Python)**
```python
from azure.identity import DefaultAzureCredential
from azure.storage.blob import BlobClient

credential = DefaultAzureCredential()
blob = BlobClient(account_url="https://staz204.blob.core.windows.net", container_name="images", blob_name="logo.png", credential=credential)
with open("logo.png", "rb") as f:
    blob.upload_blob(f, overwrite=True)
```

**Cosmos DB CRUD (JS)**
```javascript
const { CosmosClient } = require('@azure/cosmos');
const client = new CosmosClient({ endpoint, key });
const container = client.database('appdb').container('items');
await container.items.create({ id: '1', tenantId: 't1', status: 'new' });
const { resource } = await container.item('1', 't1').read();
```

**Service Bus Send/Receive (C#)**
```csharp
await using var client = new ServiceBusClient(connStr);
ServiceBusSender sender = client.CreateSender("orders");
await sender.SendMessageAsync(new ServiceBusMessage("{ 'id': 1 }") { MessageId = Guid.NewGuid().ToString() });

ServiceBusProcessor proc = client.CreateProcessor("orders", new ServiceBusProcessorOptions { MaxConcurrentCalls = 4, AutoCompleteMessages = false });
proc.ProcessMessageAsync += async args => {
  Console.WriteLine(args.Message.MessageId);
  await args.CompleteMessageAsync(args.Message);
};
proc.ProcessErrorAsync += e => Task.CompletedTask;
await proc.StartProcessingAsync();
```

**Key Vault Secret (Node)**
```javascript
const { DefaultAzureCredential } = require('@azure/identity');
const { SecretClient } = require('@azure/keyvault-secrets');
const credential = new DefaultAzureCredential();
const client = new SecretClient('https://kv-demo.vault.azure.net', credential);
const secret = await client.getSecret('SqlPassword');
```

**Feature Flag (App Configuration .NET)**
```csharp
builder.Configuration.AddAzureAppConfiguration(options => {
  options.Connect(new Uri(appConfigEndpoint), new DefaultAzureCredential())
         .UseFeatureFlags();
});
```

### 12.8 Common Exam Trick Differentiators
| Similar Services | Differentiator |
| --- | --- |
| Event Grid vs Event Hubs | Reactive notification vs high-throughput stream |
| Service Bus vs Storage Queue | Advanced features (sessions, topics) vs simple cheap queue |
| Functions vs Logic Apps | Code-first vs connector/workflow-first |
| App Config vs Key Vault | Feature flags + config vs secrets/keys/certs |
| Private Endpoint vs Service Endpoint | Private IP vs secure access over public endpoint |

### 12.9 Pricing Deep Dive (Illustrative ‚Äì Always Verify Current Portal Pricing)

Disclaimer: Pricing changes over time and varies by region. Exam expects relative comparisons and when to choose tiers, not exact dollar amounts.

#### App Service Plan Tiers
| Tier | Core Use | Scale-out Limit | Features | Notes |
| --- | --- | --- | --- | --- |
| Free (F1) | Dev/test | Shared | No custom domain SSL, limited quotas | No SLA |
| Shared (D1) | Basic shared apps | Shared | Custom domains, no SSL | No SLA |
| Basic (B) | Low traffic dedicated | Per size | Custom domains/SSL, manual scale | Cheaper entry dedicated |
| Standard (S) | Production web/API | 10 | Slots (5), daily backups, autoscale | Common exam default |
| Premium v2 (P2v2) | Larger prod | 30 | Better hardware, scale, VNet integration | Consider v3 for latest |
| Premium v3 (P1v3...) | Modern prod | 30 | Faster vCPU, more memory, zone redundancy | Lower cold start for functions on plan |
| Isolated v2 (I1v2) | High isolation | 200 | Single-tenant, VNet only | Higher cost, compliance |

#### Azure Functions Hosting Pricing Characteristics
| Plan | Billing Basis | Max Exec | Scale | Key Use |
| --- | --- | --- | --- | --- |
| Consumption | Executions + GB-s | 10 min (adj) | Dynamic up to 200 | Spiky, unpredictable load |
| Premium (EP) | vCPU & memory seconds | Unlimited | Pre-warmed elastic | Low latency, VNet needed |
| Dedicated | App Service pricing | Unlimited | Plan-dependent | Consolidate with existing plan |
| Container Apps | vCPU/Memory & requests | Unlimited | KEDA rules | Mixed container workloads |

#### Container Apps Workload Profiles (2025 snapshot)
| Profile | Target | Notes |
| --- | --- | --- |
| Consumption | Sporadic workloads | Scale to zero, pay-per-use |
| Dedicated | Consistent apps | Predictable reserved capacity |
| Premium | Latency critical | More CPU/memory per replica |

#### AKS Cost Components
| Component | Billing | Notes |
| --- | --- | --- |
| Control Plane | Free | Managed by Azure |
| Node Pools | VM pricing | Pay per node VM SKU |
| Storage | Disks/PV | Based on underlying disk type |
| Load Balancer | Standard LB cost | Egress data costs separate |
| Add-ons (Defender, ACR) | Additional | Security scanning etc. |

#### Service Bus Tiers
| Tier | Entities | Features | Use Case |
| --- | --- | --- | --- |
| Basic | Queues only | No topics, no sessions, no transactions | Simple queueing |
| Standard | Queues + Topics | Sessions, transactions, deferral | Most enterprise messaging |
| Premium | All | Dedicated resources, predictable latency, VNet, zone redundancy | High throughput, isolation |

#### Event Grid Pricing Concepts
| Metric | Note |
| --- | --- |
| Operations | Publish + delivery attempts count | Retry increases operations count |
| Advanced Filters | No extra cost | Be selective to reduce downstream noise |
| Dead-letter Storage | Standard storage billing | Needed for resiliency |

#### Event Hubs Tiers
| Tier | Throughput Units / CU | Features | Notes |
| --- | --- | --- | --- |
| Basic | TUs | No Capture, no Kafka | Simple ingestion |
| Standard | TUs | Capture, Kafka compat | Default for production |
| Premium | CUs | Dedicated compute, lower latency | Mission-critical |
| Dedicated | Capacity Units | Fully isolated, massive scale | Very high volume |

#### Storage Account Pricing Factors
| Dimension | Impact |
| --- | --- |
| Redundancy (LRS/ZRS/GRS/GZRS) | Higher redundancy = higher cost |
| Access Tier (Hot/Cool/Archive) | Cool cheaper storage, higher access cost |
| Transactions | Per 10k operations (esp. for tables/queues) |
| Data Retrieval | Archive rehydration cost/time |

#### Cosmos DB Pricing Modes
| Mode | Billing | Strengths | Considerations |
| --- | --- | --- | --- |
| Provisioned | RU/s reserved hourly | Predictable workloads | Over-provision risk |
| Autoscale | Scales 10x range | Handles peaks automatically | Pay on max RU used hour |
| Serverless | RU consumed per request | Spiky low-volume apps | Max storage / performance caps |
| Dedicated Gateway | Optional | Low-latency read caching | Additional hourly cost |

#### Azure SQL Database Pricing
| Model | Tiers | Key Features | Notes |
| --- | --- | --- | --- |
| DTU | Basic/Standard/Premium | Bundled compute+IO | Legacy measure |
| vCore | GP/Business Critical/Hyperscale | Independent compute/storage, HA options | Modern, AHB + reservations |
| Serverless (vCore) | GP only | Auto-scale & auto-pause | Cost savings for intermittent workloads |

#### API Management Tiers
| Tier | Scale | Features | Use Case |
| --- | --- | --- | --- |
| Consumption | Serverless | Pay per call, no VNet, limited policies | Low volume, prototype |
| Developer | 1 unit | Non-prod only | Testing/dev environments |
| Basic | Scale units | Core gateway | Small-mid production |
| Standard | Scale units | More throughput | Typical production |
| Premium | Multi-region, VNet | Hybrid, large enterprise | Global scale |
| Isolated | Dedicated environment | High compliance | Highly regulated |

#### Azure Cache for Redis Tiers
| Tier | Features | Use Case |
| --- | --- | --- |
| Basic | Single node | Dev/test |
| Standard | Primary/replica | Production baseline |
| Premium | Clustering, persistence, geo-rep | High availability & scale |
| Enterprise | Redis modules, active-active | Advanced analytics, multi-region |

#### Key Vault Cost Drivers
| Operation | Billed? | Note |
| --- | --- | --- |
| Secret get/set | Yes | Optimize with caching |
| Key sign/verify | Yes | HSM ops higher |
| List operations | Yes | Avoid frequent full listings |
| Event notifications | Standard event grid cost | Use selective handlers |

#### Cost Optimization Quick Wins
| Scenario | Optimization |
| --- | --- |
| Low night traffic Functions | Move to Consumption or enable scale-in schedule |
| Over-provisioned RU/s Cosmos | Switch to Autoscale or script RU changes | 
| Underutilized App Service P2v3 | Right-size to P1v3 or Sx tier if features allow |
| Chatty secret access | Cache secrets or use Key Vault reference + restart on rotation |
| High ingress AKS logs | Adjust diagnostic settings sampling |

**Exam Pricing Focus:** Choose tier offering required feature at lowest tier that satisfies scenario (e.g., need VNet + predictable messaging -> Service Bus Premium; need multi-region API gateway -> APIM Premium). Avoid over-selection (e.g., picking Premium when Standard covers needs).

---

## 13. Practice Questions & Rationales
Each question includes the BEST answer; rationales help reinforce concepts.

**1. (Integration)** You need to route certain Service Bus topic messages to a fraud analysis microservice only when `amount > 5000`. *Answer:* Subscription with SQL filter `amount > 5000`. *Rationale:* Broker-side SQL filter enables content-based routing without code changes.

**2. (Compute / Functions)** A Function must maintain state across multiple external API calls and support manual approval. *Answer:* Durable Functions (human interaction pattern). *Rationale:* Orchestrator + external event enables long-running pause/resume.

**3. (Integration / API)** You require per-request transformation, rate limiting, and versioning for an existing Function API. *Answer:* API Management. *Rationale:* Policies handle cross-cutting concerns without code redeploy.

**4. (Events)** Need real-time reaction to creation of new blobs with minimal latency and no polling. *Answer:* Event Grid subscription on Storage account. *Rationale:* Push-based native blob created events.

**5. (Data / Cosmos DB)** Multi-tenant store needs even distribution; queries filter by tenant. Partition key? *Answer:* `/tenantId`. *Rationale:* High cardinality + aligns with query filter.

**6. (Security / Networking)** App Service must be privately reachable only from VNet resources. *Answer:* Private Endpoint. *Rationale:* Allocates private IP; blocks public ingress.

**7. (Compute / Functions)** Consumption plan function hits 5-minute timeout. Need unlimited duration minimal added cost. *Answer:* Premium plan with pre-warmed instance. *Rationale:* Removes timeout + mitigates cold starts.

**8. (Messaging / Resiliency)** Guarantee effectively-once order processing for queue messages. *Answer:* Idempotent consumer + dedupe key. *Rationale:* Service Bus gives at-least-once; idempotency removes duplicates.

**9. (Configuration)** Need dynamic config + feature flags without restart. *Answer:* Azure App Configuration + feature flags. *Rationale:* Central store + refresh & targeting.

**10. (Monitoring)** Identify failing dependency causing P95 latency spike. *Answer:* KQL join `requests` and `dependencies` via `operation_Id`. *Rationale:* Correlated telemetry reveals offender.

**11. (Security / Networking)** Expose microservices with WAF, path routing, mutual TLS to backend. *Answer:* Application Gateway (WAF). *Rationale:* Layer 7 gateway supports WAF + mTLS.

**12. (Compute / Containers)** Canary deploy container with 5% traffic shift. *Answer:* Azure Container Apps revisions (traffic split). *Rationale:* Native weighted routing.

**13. (Compute / Containers)** Nightly scheduled container batch no cluster management. *Answer:* Container Apps Jobs. *Rationale:* Serverless scheduled run.

**14. (Security)** Reduce latency from frequent secret fetch + enable rotation. *Answer:* Cache secret (memory) + refresh on key change or use KV reference. *Rationale:* Fewer Key Vault calls.

**15. (Storage / Analytics)** Append ingest large files + directory analytics. *Answer:* ADLS Gen2 (hierarchical namespace). *Rationale:* Directory + ACL + analytics tooling.

**16. (Integration / API)** Throttle 1000 clients to 100 calls/min each. *Answer:* APIM inbound rate-limit policy. *Rationale:* Policy-level per-key throttling.

**17. (Events / Integration)** Need CloudEvents 1.0 to partner. *Answer:* Event Grid custom topic. *Rationale:* Native CloudEvents support.

**18. (Monitoring / Governance)** Query deployment failures across subscriptions. *Answer:* Activity Log (KQL) query. *Rationale:* Deployment events in centralized log.

**19. (Compute / Performance)** Reduce cold start for latency-sensitive HTTP orchestrations. *Answer:* Premium Functions pre-warmed instances. *Rationale:* Always warm workers.

**20. (DevOps / IaC)** Ephemeral test infra per PR auto teardown on merge. *Answer:* Bicep modules + pipeline provisioning/cleanup. *Rationale:* Fast reproducible environments.

**21. (Compute)** You need a zero-admin container solution supporting Dapr pub/sub and scale to zero for cost efficiency. Which service? *Answer:* Azure Container Apps. *Rationale:* Built-in Dapr + serverless scale unlike Web App for Containers.

**22. (Compute)** A function requires predictable low latency during business hours and may run long orchestrations. Which hosting plan? *Answer:* Premium Functions plan. *Rationale:* Eliminates cold start + unlimited duration.

**23. (Compute/DevOps)** You must deploy consistent infrastructure and app code with a single command using opinionated templates. Tool? *Answer:* Azure Developer CLI (azd). *Rationale:* Bundles infra + code with environments.

**24. (Storage)** You need immutable financial records with time-based retention and legal hold. Which blob feature? *Answer:* Immutable storage policies (time-based + legal hold). *Rationale:* WORM compliance.

**25. (Storage)** Apply lifecycle: hot -> cool after 30 days, archive after 180, delete after 7 years. Mechanism? *Answer:* Blob Lifecycle Management policy. *Rationale:* Automated tier + delete.

**26. (Cosmos DB)** Requirement: Occasional spikes to 10x baseline RU, minimize manual intervention. Choose throughput mode? *Answer:* Autoscale provisioned throughput. *Rationale:* Scales within configured max.

**27. (Cosmos DB)** Need to listen to data changes and project them to a search index. Feature? *Answer:* Change Feed + processor. *Rationale:* Incremental item change stream.

**28. (Security)** API must authenticate enterprise + personal Microsoft accounts. Authority you configure? *Answer:* `common` endpoint or multi-tenant setting. *Rationale:* Supports work/school + MSA.

**29. (Security)** Provide short-lived granular access to a single blob using Azure AD identity. Best approach? *Answer:* User Delegation SAS. *Rationale:* Scoped + identity-based vs account key SAS.

**30. (Security)** Prevent secrets in code and allow automatic rotation for DB access. Pattern? *Answer:* Managed identity + Key Vault secret reference. *Rationale:* No embedded credentials.

**31. (Security/Graph)** An API needs to call Microsoft Graph with application permissions overnight for sync. Flow? *Answer:* Client Credentials. *Rationale:* No user present, app role required.

**32. (Messaging)** Guarantee ordered processing per customer with isolated concurrency. Service Bus feature? *Answer:* Sessions. *Rationale:* FIFO scope per session id.

**33. (Messaging)** You need to route messages to different subscribers based on metadata without code changes in producers. Mechanism? *Answer:* Topic subscriptions with SQL filters. *Rationale:* Broker-based filtering.

**34. (Events)** Need push-based event notification when new resource group is created. Service? *Answer:* Event Grid (Azure Subscription/Resource Group events). *Rationale:* Native system events.

**35. (Events vs Messaging)** Real-time telemetry stream 100k events/sec for analytics. Choose? *Answer:* Event Hubs. *Rationale:* High-throughput ingestion vs Event Grid routing or Service Bus enterprise semantics.

**36. (Integration)** Publish external developer-friendly portal with subscription keys and transformation policies. Service? *Answer:* API Management. *Rationale:* Gateway + dev portal + policies.

**37. (Monitoring)** Identify top 5 slowest dependency targets over last 30 minutes. Tool/query approach? *Answer:* KQL over `dependencies` with aggregation. *Rationale:* Telemetry correlation dataset.

**38. (Monitoring)** You need immediate notification if Function error rate > 5% in 5 min windows. Alert type? *Answer:* Log alert (KQL) or metric if available. *Rationale:* Error rate derived from logs.

**39. (Optimization)** Cosmos DB 429 throttling during nightly batch. Quick mitigation (no code change)? *Answer:* Temporarily raise RU or enable autoscale max. *Rationale:* Provide capacity to avoid retry storm.

**40. (Cost)** Underutilized App Service Premium v3 instance at <10% CPU with no zone redundancy need. Optimization? *Answer:* Scale down to Standard (if features suffice). *Rationale:* Remove premium cost.

**41. (Resiliency)** Ensure at-least-once processing without duplicates in consumer logic. Approach? *Answer:* Idempotent consumer + message key persistence. *Rationale:* Service Bus offers at-least-once only.

**42. (Networking/Security)** Restrict inbound traffic to App Service from internal network only. Feature? *Answer:* Private Endpoint (or access restrictions + VNet). *Rationale:* Private IP binding inside VNet.

**43. (Functions)** Need to coordinate human approval step inside workflow. Technology? *Answer:* Durable Functions (external event pattern) or Logic Apps (approval connector). *Answer for code-first:* Durable Functions. *Rationale:* Pause/wait stateful orchestration.

**44. (Containers)** Require blue/green with 10% canary then full cutover for containerized microservice without managing full AKS. Service? *Answer:* Azure Container Apps (revision traffic split). *Rationale:* Built-in revision routing.

**45. (CI/CD)** Want preview environment per PR automatically destroyed after merge. Approach? *Answer:* Infrastructure as Code (Bicep/Terraform) + pipeline environment deployment + teardown job. *Rationale:* Ephemeral infra pattern.

**46. (App Config)** Toggle a feature gradually for 5% of users. Service? *Answer:* Azure App Configuration feature flags (label/filters). *Rationale:* Built-in targeting.

**47. (Key Vault)** High volume signing operations causing Key Vault latency. Optimization? *Answer:* Use cached symmetric key locally for non-regulated ops or switch to Premium (HSM) if required. *Rationale:* Reduce round trips / improve perf.

**48. (Data)** Need hierarchical storage with POSIX ACLs for analytics engines. Service? *Answer:* ADLS Gen2 (hierarchical namespace). *Rationale:* ACL + analytics ecosystem integration.

**49. (Auth)** SPA needs secure token acquisition w/out exposing client secret. Flow? *Answer:* Authorization Code with PKCE. *Rationale:* Recommended over implicit.

**50. (Troubleshooting)** Intermittent 500s on App Service only during traffic spikes. First diagnostic step? *Answer:* Review App Insights failures + Live Metrics (request rate vs failure correlation). *Rationale:* Fast isolation of dependency vs app issue.

> üß† Exam Focus: Distinguish event (state change broadcast ‚Äî Event Grid) vs message (command/intent ‚Äî Service Bus) vs stream (continuous high-volume telemetry ‚Äî Event Hubs).